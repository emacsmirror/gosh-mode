;;; gosh-dev.el --- Development tools for gosh-mode.el


;;; Commentary:
;; 

;;; Code:



(defun gosh-dev-find-scheme-files (dir)
  (split-string
   (shell-command-to-string
    (format "find %s \\( -name .\\?\\* -prune -or -true \\) -type f -name \\*.scm" dir)) "\n" t))



;;TODO remove duplicated values *gosh-scheme-srfi-info*
(defun gosh-dev-parse-texi (texi)
  (with-temp-buffer
    (insert-file-contents texi)
    (let (ret)
      (goto-char (point-min))
      (while (re-search-forward "^@\\(defunx?\\|defmacx?\\|defspecx?\\) \\(.*\\)" nil t)
        (let* ((type (match-string 1))
               (def (gosh-dev-split-define (match-string 2)))
               (name (intern (car def)))
               (args (gosh-dev-intern-string-args (cdr def))))
          (cond
           ((eq name '{))
           (t
            (setq ret (cons (cons name 
                                  (list (list (if (string-match "defmacx?\\|defspecx?" type) 'syntax 'lambda)
                                              (gosh-dev-create-parsing-args args))))
                            ret))))))
      (goto-char (point-min))
      (while (re-search-forward "^@\\(?:deffnx?\\) {\\([^}]+\\)} \\(.*\\)" nil t)
        (let* ((indicate (match-string 1))
               (def (gosh-dev-split-define (match-string 2)))
               (name (intern (car def)))
               (args (gosh-dev-intern-string-args (cdr def))))
          (cond
           ((eq name '{))
           ((string= indicate "EC Qualifier"))
           (t
            (setq ret (cons (cons name 
                                  (list (list 'lambda (gosh-dev-create-parsing-args args))))
                            ret))))))
      (nreverse ret))))

(defun gosh-dev-split-define (string)
  (let (arg args)
    (with-temp-buffer
      (insert string)
      (goto-char (point-min))
      (condition-case err
          (while t
            (setq a (read (current-buffer)))
            (setq args (cons (gosh-dev-sexp-to-string a) args)))
        (error nil))
      (nreverse args))))

(defun gosh-dev-sexp-to-string (sexp)
  (let ((tmp (prin1-to-string sexp)))
    (gosh-dev-replace-string tmp "\\?" "?")))

(defun gosh-dev-create-parsing-args (args)
  (let (new-args)
    (while args
      (cond
       ((eq (car args) :key)
        (setq new-args (cons (car args) new-args))
        (setq args (cdr args))
        (while args
          (setq new-args (cons (list (car args)) new-args))
          (setq args (cdr args))))
       (t
        (setq new-args (cons (car args) new-args))))
      (setq args (cdr args)))
    (nreverse new-args)))

(defun gosh-dev-intern-string-args (args)
  (mapcar 
   (lambda (arg)
     (setq arg (gosh-dev-replace-string arg "@dots{}" "..."))
     (setq arg (gosh-dev-replace-string arg "@var{optional}" ":optional"))
     (setq arg (gosh-dev-replace-string arg "@code{=>}" "'=>'"))
     (setq arg (gosh-dev-replace-all-macro arg))
     (intern arg))
   args))

(defun gosh-dev-replace-all-macro (string)
  (let ((str string))
    (setq str (gosh-dev-replace-macro str "var"))
    (setq str (gosh-dev-replace-macro str "code"))
    str))

(defun gosh-dev-replace-macro (string macro)
  (let ((regexp (format "@%s{\\([^}]*\\)}" macro))
        (str string))
    (while (string-match regexp str)
      (setq str
            (concat (substring str 0 (match-beginning 0)) 
                    (match-string 1 str)
                    (substring str (match-end 0)))))
    str))

(defun gosh-dev-replace-string (string from to)
  (let ((str string)
        (case-fold-search))
    (while (string-match (regexp-quote from) str)
      (setq str 
            (concat (substring str 0 (match-beginning 0)) 
                    to
                    (substring str (match-end 0)))))
    str))

(defun gosh-dev-parse-and-insert (file)
  (let ((exports (gosh-dev-parse-texi file)))
    (insert "(defconst *gosh-documented-exports*\n")
    (insert "'(\n")
     (mapc
      (lambda (exp)
        (insert (prin1-to-string exp) "\n"))
      (append gosh-dev-other-defined exports))
     (insert "))\n")))

(defconst *gosh-documented-exports*
  '(
    (E2BIG integer)
    (EACCES integer)
    (EADDRINUSE integer)
    (EADDRNOTAVAIL integer)
    (EADV integer)
    (EAFNOSUPPORT integer)
    (EAGAIN integer)
    (EALREADY integer)
    (EBADE integer)
    (EBADF integer)
    (EBADFD integer)
    (EBADMSG integer)
    (EBADR integer)
    (EBADRQC integer)
    (EBADSLT integer)
    (EBFONT integer)
    (EBUSY integer)
    (ECANCELED integer)
    (ECHILD integer)
    (ECHRNG integer)
    (ECOMM integer)
    (ECONNABORTED integer)
    (ECONNREFUSED integer)
    (ECONNRESET integer)
    (EDEADLK integer)
    (EDEADLOCK integer)
    (EDESTADDRREQ integer)
    (EDOM integer)
    (EDOTDOT integer)
    (EDQUOT integer)
    (EEXIST integer)
    (EFAULT integer)
    (EFBIG integer)
    (EHOSTDOWN integer)
    (EHOSTUNREACH integer)
    (EIDRM integer)
    (EILSEQ integer)
    (EINPROGRESS integer)
    (EINTR integer)
    (EINVAL integer)
    (EIO integer)
    (EISCONN integer)
    (EISDIR integer)
    (EISNAM integer)
    (EKEYEXPIRED integer)
    (EKEYREJECTED integer)
    (EKEYREVOKED integer)
    (EL2HLT integer)
    (EL2NSYNC integer)
    (EL3HLT integer)
    (EL3RST integer)
    (ELIBACC integer)
    (ELIBBAD integer)
    (ELIBEXEC integer)
    (ELIBMAX integer)
    (ELIBSCN integer)
    (ELNRNG integer)
    (ELOOP integer)
    (EMEDIUMTYPE integer)
    (EMFILE integer)
    (EMLINK integer)
    (EMSGSIZE integer)
    (EMULTIHOP integer)
    (ENAMETOOLONG integer)
    (ENAVAIL integer)
    (ENETDOWN integer)
    (ENETRESET integer)
    (ENETUNREACH integer)
    (ENFILE integer)
    (ENOANO integer)
    (ENOBUFS integer)
    (ENOCSI integer)
    (ENODATA integer)
    (ENODEV integer)
    (ENOENT integer)
    (ENOEXEC integer)
    (ENOKEY integer)
    (ENOLCK integer)
    (ENOLINK integer)
    (ENOMEDIUM integer)
    (ENOMEM integer)
    (ENOMSG integer)
    (ENONET integer)
    (ENOPKG integer)
    (ENOPROTOOPT integer)
    (ENOSPC integer)
    (ENOSR integer)
    (ENOSTR integer)
    (ENOSYS integer)
    (ENOTBLK integer)
    (ENOTCONN integer)
    (ENOTDIR integer)
    (ENOTEMPTY integer)
    (ENOTNAM integer)
    (ENOTSOCK integer)
    (ENOTTY integer)
    (ENOTUNIQ integer)
    (ENXIO integer)
    (EOPNOTSUPP integer)
    (EOVERFLOW integer)
    (EPERM integer)
    (EPFNOSUPPORT integer)
    (EPIPE integer)
    (EPROTO integer)
    (EPROTONOSUPPORT integer)
    (EPROTOTYPE integer)
    (ERANGE integer)
    (EREMCHG integer)
    (EREMOTE integer)
    (EREMOTEIO integer)
    (ERESTART integer)
    (EROFS integer)
    (ESHUTDOWN integer)
    (ESOCKTNOSUPPORT integer)
    (ESPIPE integer)
    (ESRCH integer)
    (ESRMNT integer)
    (ESTALE integer)
    (ESTRPIPE integer)
    (ETIME integer)
    (ETIMEDOUT integer)
    (ETOOMANYREFS integer)
    (ETXTBSY integer)
    (EUCLEAN integer)
    (EUNATCH integer)
    (EUSERS integer)
    (EWOULDBLOCK integer)
    (EXDEV integer)
    (EXFULL integer)
    (F_OK integer)
    (LC_ALL integer)
    (LC_COLLATE integer)
    (LC_CTYPE integer)
    (LC_MONETARY integer)
    (LC_NUMERIC integer)
    (LC_TIME integer)
    (RAND_MAX integer)
    (R_OK integer)
    (SEEK_CUR integer)
    (SEEK_END integer)
    (SEEK_SET integer)
    (SIGABRT integer)
    (SIGALRM integer)
    (SIGBUS integer)
    (SIGCHLD integer)
    (SIGCONT integer)
    (SIGFPE integer)
    (SIGHUP integer)
    (SIGILL integer)
    (SIGINT integer)
    (SIGIO integer)
    (SIGIOT integer)
    (SIGKILL integer)
    (SIGPIPE integer)
    (SIGPOLL integer)
    (SIGPROF integer)
    (SIGPWR integer)
    (SIGQUIT integer)
    (SIGSEGV integer)
    (SIGSTKFLT integer)
    (SIGSTOP integer)
    (SIGTERM integer)
    (SIGTRAP integer)
    (SIGTSTP integer)
    (SIGTTIN integer)
    (SIGTTOU integer)
    (SIGURG integer)
    (SIGUSR1 integer)
    (SIGUSR2 integer)
    (SIGVTALRM integer)
    (SIGWINCH integer)
    (SIGXCPU integer)
    (SIGXFSZ integer)
    (SIG_BLOCK integer)
    (SIG_SETMASK integer)
    (SIG_UNBLOCK integer)
    (W_OK integer)
    (X_OK integer)
    (quote (syntax (datum)))
    (lambda (syntax (formals body \.\.\.)))
    (^ (syntax (formals body \.\.\.)))
    (^c (syntax (body \.\.\.)))
    (cut (syntax (expr-or-slot expr-or-slot2 \.\.\.)))
    (cute (syntax (expr-or-slot expr-or-slot2 \.\.\.)))
    ($ (syntax (arg \.\.\.)))
    (case-lambda (syntax (clause \.\.\.)))
    (set! (syntax (symbol expression)))
    (set! (syntax (\(proc\ arg\ \.\.\.\) expression)))
    (set!-values (syntax (\(var\ \.\.\.\) expr)))
    (setter (lambda (proc)))
    (has-setter\? (lambda (proc)))
    (getter-with-setter (lambda (get set)))
    (push! (syntax (place item)))
    (pop! (syntax (place)))
    (inc! (syntax (place :optional delta)))
    (dec! (syntax (place :optional delta)))
    (update! (syntax (place proc)))
    (if (syntax (test consequent alternative)))
    (if (syntax (test consequent)))
    (cond (syntax (clause1 clause2 \.\.\.)))
    (case (syntax (key clause1 clause2 \.\.\.)))
    (ecase (syntax (key clause1 clause2 \.\.\.)))
    (and (syntax (test \.\.\.)))
    (or (syntax (test \.\.\.)))
    (when (syntax (test body \.\.\.)))
    (unless (syntax (test body \.\.\.)))
    (let (syntax (\(\(var\ expr\)\ \.\.\.\) body \.\.\.)))
    (let* (syntax (\(\(var\ expr\)\ \.\.\.\) body \.\.\.)))
    (letrec (syntax (\(\(var\ expr\)\ \.\.\.\) body \.\.\.)))
    (let1 (syntax (var expr body \.\.\.)))
    (if-let1 (syntax (var expr then)))
    (if-let1 (syntax (var expr then else)))
    (rlet1 (syntax (var expr body \.\.\.)))
    (and-let* (syntax (\(binding\ \.\.\.\) body \.\.\.)))
    (fluid-let (syntax (\(\(var\ val\)\ \.\.\.\) body \.\.\.)))
    (receive (syntax (formals expression body \.\.\.)))
    (rec (syntax (var expr)))
    (rec (syntax (\(name\ \.\ vars\) expr \.\.\.)))
    (begin (syntax (form \.\.\.)))
    (begin0 (syntax (exp0 exp1 \.\.\.)))
    (do (syntax (\(\(variable\ init\ \[step\]\)\ \.\.\.\) \(test\ expr\ \.\.\.\) body \.\.\.)))
    (let (syntax (name bindings body \.\.\.)))
    (dotimes (syntax (\(variable\ limit\ \[result\]\) body \.\.\.)))
    (dolist (syntax (\(variable\ lexpr\ \[result\]\) body \.\.\.)))
    (while (syntax (expr body \.\.\.)))
    (while (syntax (expr \'=>\' var body \.\.\.)))
    (while (syntax (expr guard \'=>\' var body \.\.\.)))
    (until (syntax (expr body \.\.\.)))
    (until (syntax (expr guard \'=>\' var body \.\.\.)))
    (quasiquote (syntax (template)))
    (unquote (syntax (datum \.\.\.)))
    (unquote-splicing (syntax (datum \.\.\.)))
    (define (syntax (variable expression)))
    (define (syntax (\(variable\ \.\ formals\) body \.\.\.)))
    (define-values (syntax (\(var\ \.\.\.\) expr)))
    (define-constant (syntax (variable expression)))
    (define-constant (syntax (\(variable\ \.\ formals\) body \.\.\.)))
    (define-in-module (syntax (module variable expression)))
    (define-in-module (syntax (module \(variable\ \.\ formals\) body \.\.\.)))
    (define-module (syntax (name body \.\.\.)))
    (select-module (syntax (name)))
    (with-module (syntax (name body \.\.\.)))
    (current-module (syntax nil))
    (export (syntax (symbol \.\.\.)))
    (export-all (syntax nil))
    (import (syntax (import-spec \.\.\.)))
    (use (syntax (name :key (only) (except) (rename) (prefix))))
    (extend (syntax (module-name \.\.\.)))
    (module\? (lambda (obj)))
    (find-module (lambda (name)))
    (make-module (lambda (name :key (if-exists))))
    (all-modules (lambda nil))
    (module-name (lambda (module)))
    (module-imports (lambda (module)))
    (module-exports (lambda (module)))
    (module-table (lambda (module)))
    (module-parents (lambda (module)))
    (module-precedence-list (lambda (module)))
    (global-variable-bound\? (lambda (module symbol)))
    (global-variable-ref (lambda (module symbol :optional default)))
    (module-name->path (lambda (symbol)))
    (path->module-name (lambda (string)))
    (define-syntax (syntax (name transformer-spec)))
    (let-syntax (syntax (\(\(name\ transformer-spec\)\ \.\.\.\) body)))
    (letrec-syntax (syntax (\(\(name\ transformer-spec\)\ \.\.\.\) body)))
    (syntax-rules (syntax (literals clause1 clause2 \.\.\.)))
    (define-macro (syntax (name procedure)))
    (define-macro (syntax (\(name\ \.\ formals\) body \.\.\.)))
    (macroexpand (lambda (form)))
    (macroexpand-1 (lambda (form)))
    (%macroexpand (syntax (form)))
    (%macroexpand-1 (syntax (form)))
    (syntax-error (syntax (msg arg \.\.\.)))
    (syntax-errorf (syntax (fmt arg \.\.\.)))
    (unwrap-syntax (lambda (form)))
    (class-of (lambda (obj)))
    (is-a\? (lambda (obj class)))
    (subtype\? (lambda (sub super)))
    (eq\? (lambda (obj1 obj2)))
    (eqv\? (lambda (obj1 obj2)))
    (equal\? (lambda (obj1 obj2)))
    (number\? (lambda (obj)))
    (complex\? (lambda (obj)))
    (real\? (lambda (obj)))
    (rational\? (lambda (obj)))
    (integer\? (lambda (obj)))
    (real-valued\? (lambda (obj)))
    (rational-valued\? (lambda (obj)))
    (integer-valued\? (lambda (obj)))
    (exact\? (lambda (obj)))
    (inexact\? (lambda (obj)))
    (zero\? (lambda (z)))
    (positive\? (lambda (x)))
    (negative\? (lambda (x)))
    (finite\? (lambda (z)))
    (infinite\? (lambda (z)))
    (nan\? (lambda (z)))
    (odd\? (lambda (n)))
    (even\? (lambda (n)))
    (fixnum\? (lambda (n)))
    (bignum\? (lambda (n)))
    (= (lambda (z1 z2 z3 \.\.\.)))
    (< (lambda (x1 x2 x3 \.\.\.)))
    (<= (lambda (x1 x2 x3 \.\.\.)))
    (> (lambda (x1 x2 x3 \.\.\.)))
    (>= (lambda (x1 x2 x3 \.\.\.)))
    (max (lambda (x1 x2 \.\.\.)))
    (min (lambda (x1 x2 \.\.\.)))
    (min&max (lambda (x1 x2 \.\.\.)))
    (+ (lambda (z \.\.\.)))
    (* (lambda (z \.\.\.)))
    (- (lambda (z1 z2 \.\.\.)))
    (/ (lambda (z1 z2 \.\.\.)))
    (+\\\. (lambda (z \.\.\.)))
    (*\\\. (lambda (z \.\.\.)))
    (-\\\. (lambda (z1 z2 \.\.\.)))
    (/\\\. (lambda (z1 z2 \.\.\.)))
    (abs (lambda (z)))
    (quotient (lambda (n1 n2)))
    (remainder (lambda (n1 n2)))
    (modulo (lambda (n1 n2)))
    (quotient&remainder (lambda (n1 n2)))
    (div (lambda (x y)))
    (mod (lambda (x y)))
    (div-and-mod (lambda (x y)))
    (div0 (lambda (x y)))
    (mod0 (lambda (x y)))
    (div0-and-mod0 (lambda (x y)))
    (gcd (lambda (n \.\.\.)))
    (lcm (lambda (n \.\.\.)))
    (numerator (lambda (q)))
    (denominator (lambda (q)))
    (floor (lambda (x)))
    (ceiling (lambda (x)))
    (truncate (lambda (x)))
    (round (lambda (x)))
    (floor->exact (lambda (x)))
    (ceiling->exact (lambda (x)))
    (truncate->exact (lambda (x)))
    (round->exact (lambda (x)))
    (clamp (lambda (x :optional min max)))
    (exp (lambda (z)))
    (log (lambda (z)))
    (log (lambda (z1 z2)))
    (sin (lambda (z)))
    (cos (lambda (z)))
    (tan (lambda (z)))
    (asin (lambda (z)))
    (acos (lambda (z)))
    (atan (lambda (z)))
    (atan (lambda (y x)))
    (sinh (lambda (z)))
    (cosh (lambda (z)))
    (tanh (lambda (z)))
    (asinh (lambda (z)))
    (acosh (lambda (z)))
    (atanh (lambda (z)))
    (sqrt (lambda (z)))
    (exact-integer-sqrt (lambda (k)))
    (expt (lambda (z1 z2)))
    (fixnum-width (lambda nil))
    (greatest-fixnum (lambda nil))
    (least-fixnum (lambda nil))
    (make-rectangular (lambda (x1 x2)))
    (make-polar (lambda (x1 x2)))
    (real-part (lambda (z)))
    (imag-part (lambda (z)))
    (magnitude (lambda (z)))
    (angle (lambda (z)))
    (decode-float (lambda (x)))
    (fmod (lambda (x y)))
    (modf (lambda (x)))
    (frexp (lambda (x)))
    (ldexp (lambda (x n)))
    (exact (lambda (z)))
    (inexact (lambda (z)))
    (exact->inexact (lambda (z)))
    (inexact->exact (lambda (z)))
    (number->string (lambda (z :optional radix use-upper\?)))
    (string->number (lambda (string :optional radix)))
    (ash (lambda (n count)))
    (logand (lambda (n1 \.\.\.)))
    (logior (lambda (n1 \.\.\.)))
    (logxor (lambda (n1 \.\.\.)))
    (lognot (lambda (n)))
    (logtest (lambda (n1 n2 \.\.\.)))
    (logbit\? (lambda (index n)))
    (bit-field (lambda (n start end)))
    (copy-bit (lambda (index n bit)))
    (copy-bit-field (lambda (n start end from)))
    (logcount (lambda (n)))
    (integer-length (lambda (n)))
    (native-endian (lambda nil))
    (not (lambda (obj)))
    (boolean\? (lambda (obj)))
    (boolean (lambda (obj)))
    (undefined\? (lambda (obj)))
    (undefined (lambda nil))
    (pair\? (lambda (obj)))
    (null\? (lambda (obj)))
    (null-list\? (lambda (obj)))
    (list\? (lambda (obj)))
    (proper-list\? (lambda (x)))
    (circular-list\? (lambda (x)))
    (dotted-list\? (lambda (x)))
    (cons (lambda (obj1 obj2)))
    (make-list (lambda (len :optional fill)))
    (list (lambda (obj \.\.\.)))
    (list* (lambda (obj1 obj2 \.\.\.)))
    (cons* (lambda (obj1 obj2 \.\.\.)))
    (list-copy (lambda (list)))
    (iota (lambda (count :optional \(start\ 0\) \(step\ 1\))))
    (cond-list (syntax (clause \.\.\.)))
    (car (lambda (pair)))
    (cdr (lambda (pair)))
    (set-car! (lambda (pair obj)))
    (set-cdr! (lambda (pair obj)))
    (caar (lambda (pair)))
    (cadr (lambda (pair)))
    (cdddar (lambda (pair)))
    (cddddr (lambda (pair)))
    (length (lambda (list)))
    (length+ (lambda (x)))
    (take (lambda (x i)))
    (drop (lambda (x i)))
    (take* (lambda (list k :optional)))
    (drop* (lambda (list k)))
    (take-right (lambda (lis k)))
    (drop-right (lambda (lis k)))
    (take-right* (lambda (list k :optional)))
    (drop-right* (lambda (list k)))
    (take! (lambda (lis k)))
    (drop-right! (lambda (lis k)))
    (list-tail (lambda (list k :optional fallback)))
    (list-ref (lambda (list k :optional fallback)))
    (last-pair (lambda (list)))
    (last (lambda (pair)))
    (split-at (lambda (x i)))
    (split-at! (lambda (x i)))
    (split-at* (lambda (list k :optional)))
    (slices (lambda (list k :optional fill\? padding)))
    (intersperse (lambda (item list)))
    (map (lambda (proc list1 list2 \.\.\.)))
    (map* (lambda (proc tail-proc list1 list2 \.\.\.)))
    (for-each (lambda (proc list1 list2 \.\.\.)))
    (fold (lambda (kons knil clist1 clist2 \.\.\.)))
    (fold-right (lambda (kons knil clist1 clist2 \.\.\.)))
    (fold-left (lambda (snok knil clist1 clist2 \.\.\.)))
    (filter (lambda (pred list)))
    (filter! (lambda (pred list)))
    (filter-map (lambda (f clist1 clist2 \.\.\.)))
    (remove (lambda (pred list)))
    (remove! (lambda (pred list)))
    (find (lambda (pred clist)))
    (find-tail (lambda (pred clist)))
    (any (lambda (pred clist1 clist2 \.\.\.)))
    (every (lambda (pred clist1 clist2 \.\.\.)))
    (delete (lambda (x list :optional elt=)))
    (delete! (lambda (x list :optional elt=)))
    (delete-duplicates (lambda (list :optional elt=)))
    (delete-duplicates! (lambda (list :optional elt=)))
    (append (lambda (list \.\.\.)))
    (append! (lambda (list \.\.\.)))
    (reverse (lambda (list :optional \(tail\ \(quote\ nil\)\))))
    (reverse! (lambda (list :optional \(tail\ \(quote\ nil\)\))))
    (memq (lambda (obj list)))
    (memv (lambda (obj list)))
    (member (lambda (obj list :optional obj=)))
    (acons (lambda (obj1 obj2 obj3)))
    (alist-copy (lambda (alist)))
    (assq (lambda (obj list)))
    (assv (lambda (obj list)))
    (assoc (lambda (obj list :optional key=)))
    (alist-delete (lambda (key alist :optional key=)))
    (alist-delete! (lambda (key alist :optional key=)))
    (rassoc (lambda (key alist :optional eq-fn)))
    (rassq (lambda (key alist)))
    (rassv (lambda (key alist)))
    (assoc-ref (lambda (alist key :optional default eq-fn)))
    (assq-ref (lambda (alist key :optional default)))
    (assv-ref (lambda (alist key :optional default)))
    (rassoc-ref (lambda (alist key :optional default eq-fn)))
    (rassq-ref (lambda (alist key :optional default)))
    (rassv-ref (lambda (alist key :optional default)))
    (assoc-set! (lambda (alist key val :optional eq-fn)))
    (assq-set! (lambda (alist key val)))
    (assv-set! (lambda (alist key val)))
    (symbol\? (lambda (obj)))
    (symbol-interned\? (lambda (symbol)))
    (symbol->string (lambda (symbol)))
    (string->symbol (lambda (string)))
    (string->uninterned-symbol (lambda (string)))
    (gensym (lambda (:optional prefix)))
    (symbol-sans-prefix (lambda (symbol prefix)))
    (keyword\? (lambda (obj)))
    (make-keyword (lambda (name)))
    (keyword->string (lambda (keyword)))
    (get-keyword (lambda (key kv-list :optional fallback)))
    (get-keyword* (syntax (key kv-list :optional fallback)))
    (delete-keyword (lambda (key kv-list)))
    (delete-keyword! (lambda (key kv-list)))
    (delete-keywords (lambda (keys kv-list)))
    (delete-keywords! (lambda (keys kv-list)))
    (identifier\? (lambda (obj)))
    (identifier->symbol (lambda (identifier)))
    (char\? (lambda (obj)))
    (char=\? (lambda (char1 char2 char3 \.\.\.)))
    (char<\? (lambda (char1 char2 char3 \.\.\.)))
    (char<=\? (lambda (char1 char2 char3 \.\.\.)))
    (char>\? (lambda (char1 char2 char3 \.\.\.)))
    (char>=\? (lambda (char1 char2 char3 \.\.\.)))
    (char-ci=\? (lambda (char1 char2 char3 \.\.\.)))
    (char-ci<\? (lambda (char1 char2 char3 \.\.\.)))
    (char-ci<=\? (lambda (char1 char2 char3 \.\.\.)))
    (char-ci>\? (lambda (char1 char2 char3 \.\.\.)))
    (char-ci>=\? (lambda (char1 char2 char3 \.\.\.)))
    (char-alphabetic\? (lambda (char)))
    (char-numeric\? (lambda (char)))
    (char-whitespace\? (lambda (char)))
    (char-upper-case\? (lambda (char)))
    (char-lower-case\? (lambda (char)))
    (char->integer (lambda (char)))
    (integer->char (lambda (n)))
    (char->ucs (lambda (char)))
    (ucs->char (lambda (n)))
    (char-upcase (lambda (char)))
    (char-downcase (lambda (char)))
    (char-titlecase (lambda (char)))
    (char-foldcase (lambda (char)))
    (digit->integer (lambda (char :optional \(radix\ 10\))))
    (integer->digit (lambda (integer :optional \(radix\ 10\))))
    (gauche-character-encoding (lambda nil))
    (supported-character-encodings (lambda nil))
    (char-set\? (lambda (obj)))
    (char-set-contains\? (lambda (char-set char)))
    (char-set (lambda (char \.\.\.)))
    (char-set-copy (lambda (char-set)))
    (char-set-complement (lambda (char-set)))
    (char-set-complement! (lambda (char-set)))
    (string\? (lambda (obj)))
    (string-immutable\? (lambda (obj)))
    (string-incomplete\? (lambda (obj)))
    (make-string (lambda (k :optional char)))
    (make-byte-string (lambda (k :optional byte)))
    (string (lambda (char \.\.\.)))
    (string-length (lambda (string)))
    (string-size (lambda (string)))
    (string-ref (lambda (cstring k :optional fallback)))
    (string-byte-ref (lambda (string k)))
    (string-set! (lambda (string k char)))
    (string-byte-set! (lambda (string k byte)))
    (string=\? (lambda (string1 string2)))
    (string-ci=\? (lambda (string1 string2)))
    (string<\? (lambda (string1 string2)))
    (string<=\? (lambda (string1 string2)))
    (string>\? (lambda (string1 string2)))
    (string>=\? (lambda (string1 string2)))
    (string-ci<\? (lambda (string1 string2)))
    (string-ci<=\? (lambda (string1 string2)))
    (string-ci>\? (lambda (string1 string2)))
    (string-ci>=\? (lambda (string1 string2)))
    (substring (lambda (string start end)))
    (string-append (lambda (string \.\.\.)))
    (string->list (lambda (string :optional start end)))
    (list->string (lambda (list)))
    (string-copy (lambda (string :optional start end)))
    (string-fill! (lambda (string char :optional start end)))
    (string-join (lambda (strs :optional delim grammer)))
    (string-scan (lambda (string item :optional return)))
    (string-scan-right (lambda (string item :optional return)))
    (string-split (lambda (string splitter)))
    (string-incomplete->complete (lambda (str :optional handling)))
    (string->regexp (lambda (string :key (case-fold))))
    (regexp\? (lambda (obj)))
    (regexp->string (lambda (regexp)))
    (rxmatch (lambda (regexp string)))
    (rxmatch-start (lambda (match :optional \(i\ 0\))))
    (rxmatch-end (lambda (match :optional \(i\ 0\))))
    (rxmatch-substring (lambda (match :optional \(i\ 0\))))
    (rxmatch-num-matches (lambda (match)))
    (rxmatch-after (lambda (match :optional \(i\ 0\))))
    (rxmatch-before (lambda (match :optional \(i\ 0\))))
    (rxmatch->string (lambda (regexp string :optional selector \.\.\.)))
    (regexp-replace (lambda (regexp string substitution)))
    (regexp-replace-all (lambda (regexp string substitution)))
    (regexp-replace* (lambda (string rx1 sub1 rx2 sub2 \.\.\.)))
    (regexp-replace-all* (lambda (string rx1 sub1 rx2 sub2 \.\.\.)))
    (regexp-quote (lambda (string)))
    (regexp-num-groups (lambda (regexp)))
    (regexp-named-groups (lambda (regexp)))
    (rxmatch-let (syntax (match-expr \(var\ \.\.\.\) form \.\.\.)))
    (rxmatch-if (syntax (match-expr \(var\ \.\.\.\) then-form else-form)))
    (rxmatch-cond (syntax (clause \.\.\.)))
    (rxmatch-case (syntax (string-expr clause \.\.\.)))
    (regexp-parse (lambda (string :key (case-fold))))
    (regexp-optimize (lambda (ast)))
    (regexp-compile (lambda (ast)))
    (regexp-ast (lambda (regexp)))
    (regexp-unparse (lambda (ast :key (\(on-error\ :error\)))))
    (vector\? (lambda (obj)))
    (make-vector (lambda (k :optional fill)))
    (vector (lambda (obj \.\.\.)))
    (vector-length (lambda (vector)))
    (vector-ref (lambda (vector k :optional fallback)))
    (vector-set! (lambda (vector k obj)))
    (vector->list (lambda (vector :optional start end)))
    (list->vector (lambda (list :optional start end)))
    (vector-fill! (lambda (vector fill :optional start end)))
    (vector-copy (lambda (vector :optional start end fill)))
    (make-hash-table (lambda (:optional type)))
    (hash (lambda (obj)))
    (eq-hash (lambda (obj)))
    (eqv-hash (lambda (obj)))
    (hash-table\? (lambda (obj)))
    (hash-table-type (lambda (ht)))
    (hash-table-num-entries (lambda (ht)))
    (hash-table (lambda (type key&value \.\.\.)))
    (hash-table-get (lambda (ht key :optional default)))
    (hash-table-put! (lambda (ht key value)))
    (hash-table-exists\? (lambda (ht key)))
    (hash-table-delete! (lambda (ht key)))
    (hash-table-clear! (lambda (ht)))
    (hash-table-push! (lambda (ht key value)))
    (hash-table-pop! (lambda (ht key :optional default)))
    (hash-table-update! (lambda (ht key proc :optional default)))
    (hash-table-for-each (lambda (ht proc)))
    (hash-table-map (lambda (ht proc)))
    (hash-table-fold (lambda (ht kons knil)))
    (hash-table-keys (lambda (ht)))
    (hash-table-values (lambda (ht)))
    (alist->hash-table (lambda (alist :optional cmp)))
    (hash-table->alist (lambda (hash-table)))
    (make-tree-map (lambda (key=\? key<\?)))
    (tree-map-copy (lambda (tree-map)))
    (tree-map-empty\? (lambda (tree-map)))
    (tree-map-num-entries (lambda (tree-map)))
    (tree-map-exists\? (lambda (tree-map key)))
    (tree-map-get (lambda (tree-map key :optional fallback)))
    (tree-map-put! (lambda (tree-map key value)))
    (tree-map-delete! (lambda (tree-map key)))
    (tree-map-clear! (lambda (tree-map)))
    (tree-map-update! (lambda (tree-map key proc :optional fallback)))
    (tree-map-push! (lambda (tree-map key value)))
    (tree-map-pop! (lambda (tree-map key :optional fallback)))
    (tree-map-min (lambda (tree-map)))
    (tree-map-max (lambda (tree-map)))
    (tree-map-pop-min! (lambda (tree-map)))
    (tree-map-pop-max! (lambda (tree-map)))
    (tree-map-fold (lambda (tree-map proc seed)))
    (tree-map-fold-right (lambda (tree-map proc seed)))
    (tree-map-map (lambda (tree-map proc)))
    (tree-map-for-each (lambda (tree-map proc)))
    (tree-map-floor (lambda (tree-map probe :optional fallback-key fallback-value)))
    (tree-map-ceiling (lambda (tree-map probe :optional fallback-key fallback-value)))
    (tree-map-predecessor (lambda (tree-map probe :optional fallback-key fallback-value)))
    (tree-map-successor (lambda (tree-map probe :optional fallback-key fallback-value)))
    (tree-map-floor-key (lambda (tree-map probe :optional fallback-key)))
    (tree-map-ceiling-key (lambda (tree-map probe :optional fallback-key)))
    (tree-map-predecessor-key (lambda (tree-map probe :optional fallback-key)))
    (tree-map-successor-key (lambda (tree-map probe :optional fallback-key)))
    (tree-map-floor-value (lambda (tree-map probe :optional fallback-value)))
    (tree-map-ceiling-value (lambda (tree-map probe :optional fallback-value)))
    (tree-map-predecessor-value (lambda (tree-map probe :optional fallback-value)))
    (tree-map-successor-value (lambda (tree-map probe :optional fallback-value)))
    (tree-map-keys (lambda (tree-map)))
    (tree-map-values (lambda (tree-map)))
    (tree-map->alist (lambda (tree-map)))
    (alist->tree-map (lambda (alist key=\? key<\?)))
    (make-weak-vector (lambda (size)))
    (weak-vector-length (lambda (wvec)))
    (weak-vector-ref (lambda (wvec k &optioal fallback)))
    (weak-vector-set! (lambda (wvec k obj)))
    (procedure\? (lambda (obj)))
    (apply (lambda (proc arg1 \.\.\. args)))
    (applicable\? (lambda (obj class \.\.\.)))
    (~ (lambda (obj key keys \.\.\.)))
    (pa$ (lambda (proc arg \.\.\.)))
    (apply$ (lambda (proc)))
    (map$ (lambda (proc)))
    (for-each$ (lambda (proc)))
    (count$ (lambda (pred)))
    (fold$ (lambda (kons :optional knil)))
    (fold-right$ (lambda (kons :optional knil)))
    (reduce$ (lambda (f :optional ridentity)))
    (reduce-right$ (lambda (f :optional ridentity)))
    (filter$ (lambda (pred)))
    (remove$ (lambda (pred)))
    (partition$ (lambda (pred)))
    (member$ (lambda (item)))
    (find$ (lambda (pred)))
    (find-tail$ (lambda (pred)))
    (any$ (lambda (pred)))
    (every$ (lambda (pred)))
    (delete$ (lambda (pred)))
    (assoc$ (lambda (item)))
    (\\\.$ (lambda (f \.\.\.)))
    (compose (lambda (f \.\.\.)))
    (complement (lambda (pred)))
    (any-pred (lambda (pred \.\.\.)))
    (every-pred (lambda (pred \.\.\.)))
    (let-optionals* (syntax (restargs \(var-spec\ \.\.\.\) body \.\.\.)))
    (let-optionals* (syntax (restargs \(var-spec\ \.\.\.\ \.\ restvar\) body \.\.\.)))
    (get-optional (syntax (restargs default)))
    (let-keywords (syntax (restarg \(var-spec\ \.\.\.\) body \.\.\.)))
    (let-keywords (syntax (restarg \(var-spec\ \.\.\.\ \.\ restvar\) body \.\.\.)))
    (let-keywords* (syntax (restarg \(var-spec\ \.\.\.\) body \.\.\.)))
    (let-keywords* (syntax (restarg \(var-spec\ \.\.\.\ \.\ restvar\) body \.\.\.)))
    (arity (lambda (proc)))
    (arity-at-least\? (lambda (obj)))
    (arity-at-least-value (lambda (arity-at-least)))
    (procedure-arity-includes\? (lambda (proc k)))
    (call-with-current-continuation (lambda (proc)))
    (call/cc (lambda (proc)))
    (let/cc (syntax (var body \.\.\.)))
    (dynamic-wind (lambda (before thunk after)))
    (values (lambda (obj \.\.\.)))
    (call-with-values (lambda (producer consumer)))
    (values-ref (syntax (mv-expr k)))
    (values->list (syntax (mv-expr)))
    (generator-fold (lambda (proc seed gen gen2 \.\.\.)))
    (generator-fold-right (lambda (proc seed gen gen2 \.\.\.)))
    (generator-for-each (lambda (proc gen gen2 \.\.\.)))
    (generator-map (lambda (proc gen gen2 \.\.\.)))
    (lazy (syntax (expression)))
    (delay (syntax (expression)))
    (force (lambda (promise)))
    (promise\? (lambda (obj)))
    (generator->lseq (lambda (generator)))
    (generator->lseq (lambda (item \.\.\. generator)))
    (lcons (syntax (car cdr)))
    (lcons* (syntax (x \.\.\. tail)))
    (llist* (syntax (x \.\.\. tail)))
    (lrange (lambda (start :optional end step)))
    (liota (lambda (count :optional start step)))
    (error (lambda (string arg \.\.\.)))
    (error (lambda (condition-type keyword-arg \.\.\. string arg \.\.\.)))
    (errorf (lambda (fmt-string arg \.\.\.)))
    (errorf (lambda (condition-type keyword-arg \.\.\. fmt-string arg \.\.\.)))
    (raise (lambda (condition)))
    (guard (syntax (\(var\ clause\ \.\.\.\) body \.\.\.)))
    (unwind-protect (syntax (body cleanup)))
    (with-error-handler (lambda (handler thunk)))
    (current-exception-handler (lambda nil))
    (with-exception-handler (lambda (handler thunk)))
    (define-condition-type (syntax (name supertype predicate field-spec \.\.\.)))
    (condition-type\? (lambda (obj)))
    (make-condition-type (lambda (name parent field-names)))
    (make-condition (lambda (type field-name value \.\.\.)))
    (condition-has-type\? (lambda (obj type)))
    (condition-ref (lambda (condition field-name)))
    (make-compound-condition (lambda (condition0 condition1 \.\.\.)))
    (extract-condition (lambda (condition condition-type)))
    (condition (syntax (type-field-binding \.\.\.)))
    (eval (lambda (expr env)))
    (null-environment (lambda (version)))
    (scheme-report-environment (lambda (version)))
    (interaction-environment (lambda nil))
    (read-eval-print-loop (lambda (:optional reader evaluator printer prompter)))
    (with-port-locking (lambda (port thunk)))
    (port\? (lambda (obj)))
    (input-port\? (lambda (obj)))
    (output-port\? (lambda (obj)))
    (port-closed\? (lambda (port)))
    (current-input-port (lambda nil))
    (current-output-port (lambda nil))
    (current-error-port (lambda nil))
    (standard-input-port (lambda (:optional new-port)))
    (standard-output-port (lambda (:optional new-port)))
    (standard-error-port (lambda (:optional new-port)))
    (with-input-from-port (lambda (port thunk)))
    (with-output-to-port (lambda (port thunk)))
    (with-error-to-port (lambda (port thunk)))
    (with-ports (lambda (iport oport eport thunk)))
    (close-input-port (lambda (port)))
    (close-output-port (lambda (port)))
    (port-type (lambda (port)))
    (port-name (lambda (port)))
    (port-buffering (lambda (port)))
    (port-current-line (lambda (port)))
    (port-file-number (lambda (port)))
    (port-seek (lambda (port offset :optional whence)))
    (port-tell (lambda (port)))
    (copy-port (lambda (src dst :key (\(unit\ 0\)))))
    (open-input-file (lambda (filename :key (if-does-not-exist) (buffering) (element-type) (encoding) (conversion-buffer-size))))
    (open-output-file (lambda (filename :key (if-does-not-exist) (if-exists) (buffering) (element-type) (encoding) (conversion-buffer-size))))
    (call-with-input-file (lambda (string proc :key (if-does-not-exist) (buffering) (element-type) (encoding) (conversion-buffer-size))))
    (call-with-output-file (lambda (string proc :key (if-does-not-exist) (if-exists) (buffering) (element-type) (encoding) (conversion-buffer-size))))
    (with-input-from-file (lambda (string thunk :key (if-does-not-exist) (buffering) (element-type) (encoding) (conversion-buffer-size))))
    (with-output-to-file (lambda (string thunk :key (if-does-not-exist) (if-exists) (buffering) (element-type) (encoding) (conversion-buffer-size))))
    (open-input-fd-port (lambda (fd :key (buffering) (name) (owner\?))))
    (open-output-fd-port (lambda (fd :key (buffering) (name) (owner\?))))
    (port-fd-dup! (lambda (toport fromport)))
    (open-input-string (lambda (string)))
    (get-remaining-input-string (lambda (port)))
    (open-output-string (lambda nil))
    (get-output-string (lambda (port)))
    (call-with-input-string (lambda (string proc)))
    (call-with-output-string (lambda (proc)))
    (with-input-from-string (lambda (string thunk)))
    (with-output-to-string (lambda (thunk)))
    (call-with-string-io (lambda (str proc)))
    (with-string-io (lambda (str thunk)))
    (write-to-string (lambda (obj :optional writer)))
    (read-from-string (lambda (string :optional start end)))
    (open-coding-aware-port (lambda (iport)))
    (read (lambda (:optional iport)))
    (read-with-shared-structure (lambda (:optional iport)))
    (read/ss (lambda (:optional iport)))
    (read-char (lambda (:optional iport)))
    (peek-char (lambda (:optional iport)))
    (read-byte (lambda (:optional iport)))
    (peek-byte (lambda (:optional iport)))
    (read-line (lambda (:optional iport allow-byte-string\?)))
    (read-block (lambda (nbytes :optional iport)))
    (eof-object (lambda nil))
    (eof-object\? (lambda (obj)))
    (char-ready\? (lambda (port)))
    (byte-ready\? (lambda (port)))
    (define-reader-ctor (lambda (tag procedure)))
    (port->string (lambda (port)))
    (port->list (lambda (reader port)))
    (port->string-list (lambda (port)))
    (port->sexp-list (lambda (port)))
    (port-fold (lambda (fn knil reader)))
    (port-fold-right (lambda (fn knil reader)))
    (port-for-each (lambda (fn reader)))
    (port-map (lambda (fn reader)))
    (write (lambda (obj :optional port)))
    (display (lambda (obj :optional port)))
    (write-with-shared-structure (lambda (obj :optional port)))
    (write/ss (lambda (obj :optional port)))
    (write* (lambda (obj :optional port)))
    (print (lambda (expr \.\.\.)))
    (newline (lambda (:optional port)))
    (flush (lambda (:optional port)))
    (flush-all-ports (lambda nil))
    (write-char (lambda (char :optional port)))
    (write-byte (lambda (byte :optional port)))
    (format (lambda (port string arg \.\.\.)))
    (format (lambda (string arg \.\.\.)))
    (load (lambda (file :key (paths))))
    (add-load-path (syntax (path flag \.\.\.)))
    (load-from-port (lambda (port)))
    (current-load-port (lambda nil))
    (current-load-path (lambda nil))
    (current-load-history (lambda nil))
    (current-load-next (lambda nil))
    (dynamic-load (lambda (file :key (init-function) (export-symbols))))
    (require (syntax (feature)))
    (provide (lambda (feature)))
    (provided\? (lambda (feature)))
    (autoload (syntax (file/module item \.\.\.)))
    (library-fold (lambda (pattern proc seed :key (paths) (strict\?) (allow-duplicates\?))))
    (library-map (lambda (pattern proc :key (paths) (allow-duplicates\?) (strict\?))))
    (library-for-each (lambda (pattern proc :key (paths) (allow-duplicates\?) (strict\?))))
    (library-exists\? (lambda (mod/path :key (paths) (force-search\?) (strict\?))))
    (library-has-module\? (lambda (path module)))
    (compare (lambda (obj1 obj2)))
    (sort (lambda (seq :optional cmpfn)))
    (sort! (lambda (seq :optional cmpfn)))
    (stable-sort (lambda (seq :optional cmpfn)))
    (stable-sort! (lambda (seq :optional cmpfn)))
    (sort-by (lambda (seq key :optional cmpfn)))
    (sort-by! (lambda (seq key :optional cmpfn)))
    (stable-sort-by (lambda (seq key :optional cmpfn)))
    (stable-sort-by! (lambda (seq key :optional cmpfn)))
    (exit (lambda (:optional \(code\ 0\))))
    (exit-handler (lambda (:optional new-handler)))
    (sys-exit (lambda (code)))
    (sys-abort (lambda nil))
    (sys-getenv (lambda (name)))
    (sys-environ (lambda nil))
    (sys-environ->alist (lambda (:optional envlist)))
    (sys-setenv (lambda (name value &optional overwrite)))
    (sys-putenv (lambda (name=value)))
    (sys-unsetenv (lambda (name)))
    (sys-clearenv (lambda nil))
    (gauche-version (lambda nil))
    (gauche-architecture (lambda nil))
    (gauche-library-directory (lambda nil))
    (gauche-architecture-directory (lambda nil))
    (gauche-site-library-directory (lambda nil))
    (gauche-site-architecture-directory (lambda nil))
    (sys-readdir (lambda (path)))
    (glob (lambda (pattern :key (separator) (folder))))
    (sys-glob (lambda (pattern :key (separator) (folder))))
    (glob-fold (lambda (pattern proc seed :key (separator) (folder))))
    (make-glob-fs-fold (lambda (:key (root-path) (current-path))))
    (sys-remove (lambda (filename)))
    (sys-rename (lambda (old new)))
    (sys-tmpnam (lambda nil))
    (sys-mkstemp (lambda (template)))
    (sys-link (lambda (existing new)))
    (sys-unlink (lambda (pathname)))
    (sys-symlink (lambda (existing new)))
    (sys-readlink (lambda (path)))
    (sys-mkdir (lambda (pathname mode)))
    (sys-rmdir (lambda (pathname)))
    (sys-umask (lambda (:optional mode)))
    (sys-normalize-pathname (lambda (pathname :key (absolute) (expand) (canonicalize))))
    (sys-basename (lambda (pathname)))
    (sys-dirname (lambda (pathname)))
    (sys-realpath (lambda (pathname)))
    (sys-tmpdir (lambda nil))
    (file-exists\? (lambda (path)))
    (file-is-regular\? (lambda (path)))
    (file-is-directory\? (lambda (path)))
    (sys-stat (lambda (path)))
    (sys-fstat (lambda (port-or-fd)))
    (sys-lstat (lambda (path)))
    (sys-stat->mode (lambda (stat)))
    (sys-stat->ino (lambda (stat)))
    (sys-stat->dev (lambda (stat)))
    (sys-stat->rdev (lambda (stat)))
    (sys-stat->nlink (lambda (stat)))
    (sys-stat->size (lambda (stat)))
    (sys-stat->uid (lambda (stat)))
    (sys-stat->gid (lambda (stat)))
    (sys-stat->atime (lambda (stat)))
    (sys-stat->mtime (lambda (stat)))
    (sys-stat->ctime (lambda (stat)))
    (sys-stat->file-type (lambda (stat)))
    (sys-access (lambda (pathname amode)))
    (sys-chmod (lambda (path mode)))
    (sys-fchmod (lambda (port-or-fd mode)))
    (sys-chown (lambda (path owner-id group-id)))
    (sys-utime (lambda (path :optional atime mtime)))
    (sys-chdir (lambda (dir)))
    (sys-pipe (lambda (:key (\(buffering\ :line\)))))
    (sys-mkfifo (lambda (path mode)))
    (sys-isatty (lambda (port-or-fd)))
    (sys-ttyname (lambda (port-or-fd)))
    (sys-truncate (lambda (path length)))
    (sys-ftruncate (lambda (port-or-fd length)))
    (sys-getgrgid (lambda (gid)))
    (sys-getgrnam (lambda (name)))
    (sys-gid->group-name (lambda (gid)))
    (sys-group-name->gid (lambda (name)))
    (sys-getpwuid (lambda (uid)))
    (sys-getpwnam (lambda (name)))
    (sys-uid->user-name (lambda (uid)))
    (sys-user-name->uid (lambda (name)))
    (sys-crypt (lambda (key salt)))
    (sys-setlocale (lambda (category locale)))
    (sys-localeconv (lambda nil))
    (sys-sigset (lambda (signal \.\.\.)))
    (sys-sigset-add! (lambda (sigset signal \.\.\.)))
    (sys-sigset-delete! (lambda (sigset signal \.\.\.)))
    (sys-sigset-fill! (lambda (sigset)))
    (sys-sigset-empty! (lambda (sigset)))
    (sys-signal-name (lambda (signal)))
    (sys-kill (lambda (pid sig)))
    (set-signal-handler! (lambda (signals handler :optional sigmask)))
    (get-signal-handler (lambda (signum)))
    (get-signal-handler-mask (lambda (signum)))
    (get-signal-handlers (lambda nil))
    (get-signal-pending-limit (lambda nil))
    (set-signal-pending-limit (lambda (limit)))
    (with-signal-handlers (syntax (\(handler-clause\ \.\.\.\) thunk)))
    (sys-sigmask (lambda (how mask)))
    (sys-sigsuspend (lambda (mask)))
    (sys-sigwait (lambda (mask)))
    (sys-uname (lambda nil))
    (sys-gethostname (lambda nil))
    (sys-getdomainname (lambda nil))
    (sys-getcwd (lambda nil))
    (sys-getgid (lambda nil))
    (sys-getegid (lambda nil))
    (sys-setgid (lambda (gid)))
    (sys-getuid (lambda nil))
    (sys-geteuid (lambda nil))
    (sys-setuid (lambda (uid)))
    (sys-getgroups (lambda nil))
    (sys-getlogin (lambda nil))
    (sys-getpgrp (lambda nil))
    (sys-getpgid (lambda (pid)))
    (sys-setpgid (lambda (pid pgid)))
    (sys-setsid (lambda nil))
    (sys-getpid (lambda nil))
    (sys-getppid (lambda nil))
    (sys-times (lambda nil))
    (sys-ctermid (lambda nil))
    (sys-getrlimit (lambda (resource)))
    (sys-setrlimit (lambda (resource current :optional maximum)))
    (sys-strerror (lambda (errno)))
    (sys-time (lambda nil))
    (sys-gettimeofday (lambda nil))
    (sys-gmtime (lambda (time)))
    (sys-localtime (lambda (time)))
    (sys-ctime (lambda (time)))
    (sys-difftime (lambda (time1 time0)))
    (sys-asctime (lambda (tm)))
    (sys-strftime (lambda (format tm)))
    (sys-mktime (lambda (tm)))
    (sys-tm->alist (lambda (tm)))
    (current-time (lambda nil))
    (time\? (lambda (obj)))
    (time->seconds (lambda (time)))
    (seconds->time (lambda (seconds)))
    (sys-system (lambda (command)))
    (sys-fork (lambda nil))
    (sys-exec (lambda (command args :key (directory) (iomap) (sigmask))))
    (sys-fork-and-exec (lambda (command args :key (directory) (iomap) (sigmask) (detached))))
    (sys-wait (lambda nil))
    (sys-waitpid (lambda (pid :key (nohang) (untraced))))
    (sys-wait-exited\? (lambda (status)))
    (sys-wait-exit-status (lambda (status)))
    (sys-wait-signaled\? (lambda (status)))
    (sys-wait-termsig (lambda (status)))
    (sys-wait-stopped\? (lambda (status)))
    (sys-wait-stopsig (lambda (status)))
    (sys-win-process\? (lambda (obj)))
    (sys-win-process-pid (lambda (handle)))
    (sys-fdset (lambda (elt \.\.\.)))
    (sys-fdset-ref (lambda (fdset port-or-fd)))
    (sys-fdset-set! (lambda (fdset port-or-fd flag)))
    (sys-fdset-copy! (lambda (dest-fdset src-fdset)))
    (sys-fdset-clear! (lambda (fdset)))
    (sys-fdset->list (lambda (fdset)))
    (list->sys-fdset (lambda (fds)))
    (sys-fdset-max-fd (lambda (fdset)))
    (sys-select (lambda (readfds writefds exceptfds :optional timeout)))
    (sys-select! (lambda (readfds writefds exceptfds :optional timeout)))
    (sys-pause (lambda nil))
    (sys-alarm (lambda (seconds)))
    (sys-sleep (lambda (seconds)))
    (sys-nanosleep (lambda (nanoseconds)))
    (sys-random (lambda nil))
    (sys-srandom (lambda (seed)))
    (sys-get-osfhandle (lambda (port-or-fd)))
    (debug-print (syntax (expr)))
    (debug-source-info (lambda (obj)))
    (disasm (lambda (closure)))
    (profiler-start (lambda nil))
    (profiler-stop (lambda nil))
    (profiler-reset (lambda nil))
    (profiler-show (lambda (:key (sort-by) (max-rows))))
    (define-class (syntax (name supers \(slot-spec\ \.\.\.\) option \.\.\.)))
    (class-name (lambda (class)))
    (class-precedence-list (lambda (class)))
    (class-direct-supers (lambda (class)))
    (class-direct-subclasses (lambda (class)))
    (class-slots (lambda (class)))
    (class-slot-definition (lambda (class slot-name)))
    (class-direct-slots (lambda (class)))
    (class-direct-methods (lambda (class)))
    (class-slot-accessor (lambda (class slot-name)))
    (slot-definition-name (lambda (slot-def)))
    (slot-definition-options (lambda (slot-def)))
    (slot-definition-allocation (lambda (slot-def)))
    (slot-definition-getter (lambda (slot-def)))
    (slot-definition-setter (lambda (slot-def)))
    (slot-definition-accessor (lambda (slot-def)))
    (slot-definition-option (lambda (slot-def option :optional default)))
    (slot-ref (lambda (obj slot)))
    (slot-set! (lambda (obj slot value)))
    (slot-bound\? (lambda (obj slot)))
    (slot-exists\? (lambda (obj slot)))
    (slot-push! (lambda (obj slot value)))
    (slot-pop! (lambda (obj slot :optional fallback)))
    (current-class-of (lambda (obj)))
    (class-slot-ref (lambda (class slot-name)))
    (class-slot-set! (lambda (class slot-name obj)))
    (class-slot-bound\? (lambda (class slot-name obj)))
    (change-object-class (lambda (obj orig-class new-class)))
    (define-generic (syntax (name :key (class))))
    (define-method (syntax (name specs body)))
    (slot-ref-using-accessor (lambda (obj slot-accessor)))
    (slot-set-using-accessor! (lambda (obj slot-accessor value)))
    (slot-bound-using-accessor\? (lambda (obj slot-accessor)))
    (slot-initialize-using-accessor! (lambda (obj slot-accessor initargs)))
    (array\? (lambda (obj)))
    (make-array (lambda (shape :optional init)))
    (make-u8array (lambda (shape :optional init)))
    (make-s8array (lambda (shape :optional init)))
    (make-f32array (lambda (shape :optional init)))
    (make-f64array (lambda (shape :optional init)))
    (shape (lambda (bound \.\.\.)))
    (array (lambda (shape init \.\.\.)))
    (array-rank (lambda (array)))
    (array-shape (lambda (array)))
    (array-start (lambda (array dim)))
    (array-end (lambda (array dim)))
    (array-length (lambda (array dim)))
    (array-size (lambda (array)))
    (array-ref (lambda (array k \.\.\.)))
    (array-ref (lambda (array index)))
    (array-set! (lambda (array k \.\.\. value)))
    (array-set! (lambda (array index value)))
    (share-array (lambda (array shape proc)))
    (array-for-each-index (lambda (array proc :optional index)))
    (shape-for-each (lambda (shape proc :optional index)))
    (tabulate-array (lambda (shape proc :optional index)))
    (array-retabulate! (lambda (array proc :optional index)))
    (array-retabulate! (lambda (array shape proc :optional index)))
    (array-map (lambda (proc array0 array1 \.\.\.)))
    (array-map (lambda (shape proc array0 array1 \.\.\.)))
    (array-map! (lambda (array proc array0 array1 \.\.\.)))
    (array-map! (lambda (array shape proc array0 array1 \.\.\.)))
    (array->vector (lambda (array)))
    (array->list (lambda (array)))
    (array-concatenate (lambda (a b :optional dimension)))
    (array-transpose (lambda (array :optional dim1 dim2)))
    (array-rotate-90 (lambda (array :optional dim1 dim2)))
    (array-flip (lambda (array :optional dimension)))
    (array-flip! (lambda (array :optional dimension)))
    (identity-array (lambda (dimension :optional class)))
    (array-inverse (lambda (array)))
    (determinant (lambda (array)))
    (determinant! (lambda (array)))
    (array-mul (lambda (a b)))
    (array-expt (lambda (array pow)))
    (array-div-left (lambda (a b)))
    (array-div-right (lambda (a b)))
    (array-add-elements (lambda (array array-or-scalar \.\.\.)))
    (array-add-elements! (lambda (array array-or-scalar \.\.\.)))
    (array-sub-elements (lambda (array array-or-scalar \.\.\.)))
    (array-sub-elements! (lambda (array array-or-scalar \.\.\.)))
    (array-mul-elements (lambda (array array-or-scalar \.\.\.)))
    (array-mul-elements! (lambda (array array-or-scalar \.\.\.)))
    (array-div-elements (lambda (array array-or-scalar \.\.\.)))
    (array-div-elements! (lambda (array array-or-scalar \.\.\.)))
    (ces-conversion-supported\? (lambda (from-ces to-ces)))
    (ces-equivalent\? (lambda (ces-a ces-b :optional unknown-value)))
    (ces-upper-compatible\? (lambda (ces-a ces-b :optional unknown-value)))
    (ces-guess-from-string (lambda (string scheme)))
    (open-input-conversion-port (lambda (source from-code :key (to-code) (buffer-size) (owner\?))))
    (open-output-conversion-port (lambda (sink to-code :key (from-code) (buffer-size) (owner\?))))
    (ces-convert (lambda (string from-code :optional to-code)))
    (call-with-input-conversion (lambda (iport proc :key (encoding) (conversion-buffer-size))))
    (call-with-output-conversion (lambda (oport proc :key (encoding) (conversion-buffer-size))))
    (with-input-conversion (lambda (iport thunk :key (encoding) (conversion-buffer-size))))
    (with-output-conversion (lambda (oport thunk :key (encoding) (conversion-buffer-size))))
    (wrap-with-input-conversion (lambda (port from-code :key (to-code) (owner\?) (buffer-size))))
    (wrap-with-output-conversion (lambda (port to-code :key (from-code) (owner\?) (buffer-size))))
    (cgen-extern (lambda (code \.\.\.)))
    (cgen-decl (lambda (code \.\.\.)))
    (cgen-body (lambda (code \.\.\.)))
    (cgen-init (lambda (code \.\.\.)))
    (cgen-safe-name (lambda (string)))
    (cgen-safe-name-friendly (lambda (string)))
    (cgen-safe-comment (lambda (string)))
    (cgen-with-cpp-condition (syntax (cpp-expr body \.\.\.)))
    (cgen-add! (lambda (cgen-node)))
    (cgen-literal (lambda (obj)))
    (cgen-type-from-name (lambda (name)))
    (cgen-box-expr (lambda (cgen-type c-expr)))
    (cgen-unbox-expr (lambda (cgen-type c-expr)))
    (cgen-pred-expr (lambda (cgen-type c-expr)))
    (call-with-iterators (lambda (collections proc)))
    (gauche-config (lambda (option)))
    (make-bimap (lambda (left-map right-map)))
    (bimap-left (lambda (bimap)))
    (bimap-right (lambda (bimap)))
    (bimap-left-get (lambda (bimap key :optional default)))
    (bimap-right-get (lambda (bimap key :optional default)))
    (bimap-left-exists\? (lambda (bimap key)))
    (bimap-right-exists\? (lambda (bimap key)))
    (bimap-put! (lambda (bimap x y &key \(on-conflict\ :supersede\))))
    (bimap-left-delete! (lambda (bimap key)))
    (bimap-right-delete! (lambda (bimap key)))
    (sys-fcntl (lambda (port-or-fd operation :optional arg)))
    (null-generator (lambda nil))
    (circular-generator (lambda (arg \.\.\.)))
    (giota (lambda (count :optional \(start\ 0\) \(step\ 1\))))
    (grange (lambda (start :optional \(end\ +inf\\\.0\) \(step\ 1\))))
    (generate (lambda (proc)))
    (list->generator (lambda (lis :optional start end)))
    (vector->generator (lambda (vec :optional start end)))
    (reverse-vector->generator (lambda (vec :optional start end)))
    (string->generator (lambda (str :optioanl start end)))
    (bits->generator (lambda (n :optional start end)))
    (reverse-bits->generator (lambda (n :optional start end)))
    (port->char-generator (lambda (input-port)))
    (port->byte-generator (lambda (input-port)))
    (file->generator (lambda (filename reader)))
    (file->sexp-generator (lambda (filename)))
    (file->char-generator (lambda (filename)))
    (file->line-generator (lambda (filename)))
    (file->byte-generator (lambda (filename)))
    (gunfold (lambda (p f g seed :optional tail-gen)))
    (generator->list (lambda (generator :optional k)))
    (glet* (syntax (\(binding\ \.\.\.\) body body2 \.\.\.)))
    (glet1 (syntax (var expr body body2 \.\.\.)))
    (do-generator (syntax (\(var\ gexpr\) body \.\.\.)))
    (gcons* (lambda (item \.\.\. gen)))
    (gappend (lambda (gen \.\.\.)))
    (gmap (lambda (proc gen gen2 \.\.\.)))
    (gmap-accum (lambda (proc seed gen gen2 \.\.\.)))
    (gfilter (lambda (pred gen)))
    (gfilter-map (lambda (proc gen gen2 \.\.\.)))
    (gstate-filter (lambda (proc seed gen)))
    (gtake (lambda (gen k :optional)))
    (gdrop (lambda (gen k)))
    (gtake-while (lambda (pred gen)))
    (gdrop-while (lambda (pred gen)))
    (grxmatch (lambda (regexp gen)))
    (make-hook (lambda (:optional \(arity\ 0\))))
    (hook\? (lambda (obj)))
    (hook-empty\? (lambda (hook)))
    (apropos (syntax (pattern :optional module)))
    (info (lambda (symbol)))
    (x->lseq (lambda (obj)))
    (lunfold (lambda (p f g seed :optional tail-gen)))
    (lmap (lambda (proc seq seq2 \.\.\.)))
    (lmap-accum (lambda (proc seed seq seq2 \.\.\.)))
    (lappend (lambda (seq \.\.\.)))
    (lfilter (lambda (proc seq)))
    (lfilter-map (lambda (proc seq seq2 \.\.\.)))
    (lstate-filter (lambda (proc seed seq)))
    (ltake (lambda (seq n :optional fill\? padding)))
    (ltake-while (lambda (pred seq)))
    (lrxmatch (lambda (rx seq)))
    (complete-sexp\? (lambda (str)))
    (log-open (lambda (path :key (prefix) (program-name))))
    (make-sockaddrs (lambda (host port :optional proto)))
    (inet-string->address (lambda (address)))
    (inet-string->address! (lambda (address buf)))
    (inet-address->string (lambda (address protocol)))
    (make-client-socket (lambda (:optional address-spec \.\.\.)))
    (make-server-socket (lambda (:optional address-spec \.\.\.)))
    (make-server-sockets (lambda (host port :key (reuse-addr\?) (sock-init))))
    (socket-address (lambda (socket)))
    (socket-input-port (lambda (socket :key (\(buffering\ :modest\)))))
    (socket-output-port (lambda (socket :key (\(buffering\ :line\)))))
    (socket-close (lambda (socket)))
    (call-with-client-socket (lambda (socket proc :key (input-buffering) (output-buffering))))
    (make-socket (lambda (domain type :optional protocol)))
    (socket-fd (lambda (socket)))
    (socket-status (lambda (socket)))
    (socket-bind (lambda (socket address)))
    (socket-listen (lambda (socket backlog)))
    (socket-accept (lambda (socket)))
    (socket-connect (lambda (socket address)))
    (socket-shutdown (lambda (socket how)))
    (socket-getsockname (lambda (socket)))
    (socket-getpeername (lambda (socket)))
    (socket-send (lambda (socket msg :optional flags)))
    (socket-sendto (lambda (socket msg to-address :optional flags\\\.)))
    (socket-sendmsg (lambda (socket msghdr :optional flags)))
    (socket-buildmsg (lambda (addr iov control flags :optional buf)))
    (socket-recv! (lambda (socket buf :optional flags)))
    (socket-recvfrom! (lambda (socket buf addrs :optional flags)))
    (socket-recv (lambda (socket bytes :optional flags)))
    (socket-recvfrom (lambda (socket bytes :optional flags)))
    (socket-setsockopt (lambda (socket level option value)))
    (socket-getsockopt (lambda (socket level option rsize)))
    (inet-checksum (lambda (packet size)))
    (sys-gethostbyname (lambda (name)))
    (sys-gethostbyaddr (lambda (addr proto)))
    (sys-getservbyname (lambda (name proto)))
    (sys-getservbyport (lambda (port proto)))
    (sys-getprotobyname (lambda (name)))
    (sys-getprotobynumber (lambda (number)))
    (sys-getaddrinfo (lambda (nodename servname hints)))
    (sys-ntohs (lambda (integer)))
    (sys-ntohl (lambda (integer)))
    (sys-htons (lambda (integer)))
    (sys-htonl (lambda (integer)))
    (make-parameter (lambda (value :optional filter)))
    (parameterize (syntax (\(\(param\ value\)\ \.\.\.\) body \.\.\.)))
    (let-args (syntax (args)))
    (parse-options (syntax (args \(option-clause\ \.\.\.\))))
    (make-option-parser (syntax (\(option-clause\ \.\.\.\))))
    (reset (syntax (expr \.\.\.)))
    (shift (syntax (var expr \.\.\.)))
    (call/pc (lambda (proc)))
    (run-process (lambda (cmd/args :key (redirects) (input) (output) (error) (@))))
    (process\? (lambda (obj)))
    (process-alive\? (lambda (process)))
    (process-list (lambda nil))
    (process-wait (lambda (process :optional nohang error-on-nonzero-status)))
    (process-wait-any (lambda (:optional nohang)))
    (process-exit-status (lambda (process)))
    (process-send-signal (lambda (process signal)))
    (process-kill (lambda (process)))
    (process-stop (lambda (process)))
    (process-continue (lambda (process)))
    (open-input-process-port (lambda (command :key (input) (error) (encoding) (conversion-buffer-size))))
    (call-with-input-process (lambda (command proc :key (input) (error) (encoding) (conversion-buffer-size) (on-abnormal-exit))))
    (with-input-from-process (lambda (command thunk :key (input) (error) (encoding) (conversion-buffer-size) (on-abnormal-exit))))
    (open-output-process-port (lambda (command :key (output) (error) (encoding) (conversion-buffer-size))))
    (call-with-output-process (lambda (command proc :key (output) (error) (encoding) (conversion-buffer-size) (on-abnormal-exit))))
    (with-output-to-process (lambda (command thunk :key (output) (error) (encoding) (conversion-buffer-size) (on-abnormal-exit))))
    (call-with-process-io (lambda (command proc :key (error) (encoding) (conversion-buffer-size) (on-abnormal-exit))))
    (process-output->string (lambda (command :key (error) (encoding) (conversion-buffer-size) (on-abnormal-exit))))
    (process-output->string-list (lambda (command :key (error) (encoding) (conversion-buffer-size) (on-abnormal-exit))))
    (shell-escape-string (lambda (arg)))
    (define-record-type (syntax (type-spec ctor-spec pred-spec field-spec \.\.\.)))
    (record\? (lambda (obj)))
    (record-rtd (lambda (record)))
    (rtd-name (lambda (rtd)))
    (rtd-parent (lambda (rtd)))
    (rtd-field-names (lambda (rtd)))
    (rtd-all-field-names (lambda (rtd)))
    (rtd-field-mutable\? (lambda (rtd field-name)))
    (make-rtd (lambda (name field-specs :optional parent)))
    (rtd\? (lambda (obj)))
    (rtd-constructor (lambda (rtd :optional field-specs)))
    (rtd-predicate (lambda (rtd)))
    (rtd-accessor (lambda (rtd field-name)))
    (rtd-mutator (lambda (rtd field-name)))
    (pseudo-rtd (lambda (instance-class)))
    (reload (lambda (module-name :optional rule \.\.\.)))
    (reload-modified-modules (lambda (:optional module-rules)))
    (module-reload-rules (lambda (:optional module-rules)))
    (reload-verbose (lambda (:optional flag)))
    (sys-openlog (lambda (ident option facility)))
    (sys-closelog (lambda nil))
    (sys-setlogmask (lambda (mask)))
    (sys-logmask (lambda (level)))
    (sys-tcgetattr (lambda (port-or-fd)))
    (sys-tcsetattr (lambda (port-or-fd when termios)))
    (sys-tcsendbreak (lambda (port-or-fd duration)))
    (sys-tcdrain (lambda (port-or-fd)))
    (sys-tcflush (lambda (port-or-fd queue)))
    (sys-tcflow (lambda (port-or-fd action)))
    (sys-tcgetpgrp (lambda (port-or-fd)))
    (sys-tcsetpgrp (lambda (port-or-fd pgrp)))
    (sys-cfgetispeed (lambda (termios)))
    (sys-cfsetispeed (lambda (termios speed)))
    (sys-cfgetospeed (lambda (termios)))
    (sys-cfsetospeed (lambda (termios speed)))
    (sys-openpty (lambda (:optional term)))
    (sys-forkpty (lambda (:optional term)))
    (sys-forkpty-and-exec (lambda (command args :key (iomap) (term) (sigmask))))
    (without-echoing (lambda (iport proc)))
    (test-start (lambda (module-name)))
    (test-section (lambda (section-name)))
    (test-end (lambda (:key (exit-on-failure))))
    (test-record-file (lambda (file)))
    (test-summary-check (lambda nil))
    (test* (syntax (name expected expr :optional check)))
    (test (lambda (name expected thunk :optional check)))
    (test-check (lambda (expected result :optional fallback)))
    (test-one-of (lambda (choice \.\.\.)))
    (test-error (lambda (:optional \(condition-type\ <error>\))))
    (test-module (lambda (module :key (allow-undefined) (bypass-arity-check))))
    (gauche-thread-type (lambda nil))
    (current-thread (lambda nil))
    (thread\? (lambda (obj)))
    (make-thread (lambda (thunk :optional name)))
    (thread-state (lambda (thread)))
    (thread-name (lambda (thread)))
    (thread-specific (lambda (thread)))
    (thread-specific-set! (lambda (thread value)))
    (thread-start! (lambda (thread)))
    (thread-yield! (lambda nil))
    (thread-sleep! (lambda (timeout)))
    (thread-stop! (lambda (thread :optional timeout timeout-val)))
    (thread-cont! (lambda (thread)))
    (thread-terminate! (lambda (thread)))
    (thread-join! (lambda (thread :optional timeout timeout-val)))
    (mutex\? (lambda (obj)))
    (make-mutex (lambda (:optional name)))
    (mutex-name (lambda (mutex)))
    (mutex-specific (lambda (mutex)))
    (mutex-specific-set! (lambda (mutex value)))
    (mutex-state (lambda (mutex)))
    (mutex-lock! (lambda (mutex :optional timeout thread)))
    (mutex-unlock! (lambda (mutex :optional condition-variable timeout)))
    (mutex-locker (lambda (mutex)))
    (mutex-unlocker (lambda (mutex)))
    (with-locking-mutex (lambda (mutex thunk)))
    (condition-variable\? (lambda (obj)))
    (make-condition-variable (lambda (:optional name)))
    (condition-variable-name (lambda (cv)))
    (condition-variable-specific (lambda (cv)))
    (condition-variable-specific-set! (lambda (cv value)))
    (condition-variable-signal! (lambda (cv)))
    (condition-variable-broadcast! (lambda (cv)))
    (atom (lambda (val \.\.\.)))
    (atom\? (lambda (obj)))
    (atom-ref (lambda (atom :optional index timeout timeout-val)))
    (atomic (lambda (atom proc :optional timeout timeout-val)))
    (atomic-update! (lambda (atom proc :optional timeout timeout-val)))
    (join-timeout-exception\? (lambda (obj)))
    (abandoned-mutex-exception\? (lambda (obj)))
    (terminated-thread-exception\? (lambda (obj)))
    (uncaught-exception\? (lambda (obj)))
    (uncaught-exception-reason (lambda (exc)))
    (time (syntax (expr expr2 \.\.\.)))
    (time-this (lambda (how thunk)))
    (make-time-result (lambda (count real user sys)))
    (time-result\? (lambda (obj)))
    (time-result+ (lambda (t1 t2 :key)))
    (time-result- (lambda (t1 t2 :key)))
    (time-these (lambda (how alist)))
    (time-these/report (lambda (how alist)))
    (report-time-results (lambda (result)))
    (with-time-counter (syntax (counter expr \.\.\.)))
    (uvector-size (lambda (uvector :optional start end)))
    (uvector-copy! (lambda (target tstart source :optional sstart send)))
    (string->s8vector (lambda (string :optional start end)))
    (string->u8vector (lambda (string :optional start end)))
    (string->s8vector! (lambda (target tstart string :optional start end)))
    (string->u8vector! (lambda (target tstart string :optional start end)))
    (s8vector->string (lambda (vec :optional start end)))
    (u8vector->string (lambda (vec :optional start end)))
    (string->s32vector (lambda (string :optional start end)))
    (string->u32vector (lambda (string :optional start end)))
    (s32vector->string (lambda (vec :optional start end)))
    (u32vector->string (lambda (vec :optional start end)))
    (uvector-alias (lambda (uvector-class vec :optional start end)))
    (read-block! (lambda (vec :optional iport start end endian)))
    (write-block (lambda (vec :optional oport start end endian)))
    (version=\? (lambda (ver1 ver2)))
    (version<\? (lambda (ver1 ver2)))
    (version<=\? (lambda (ver1 ver2)))
    (version>\? (lambda (ver1 ver2)))
    (version>=\? (lambda (ver1 ver2)))
    (version-compare (lambda (ver1 ver2)))
    (relnum-compare (lambda (rel1 rel2)))
    (open-input-uvector (lambda (uvector)))
    (open-output-uvector (lambda (uvector)))
    (cond-expand (syntax (\(feature-requirement\ command-or-definition\ \.\.\.\) \.\.\.)))
    (xcons (lambda (cd ca)))
    (list-tabulate (lambda (n init-proc)))
    (circular-list (lambda (elt1 elt2 \.\.\.)))
    (not-pair\? (lambda (x)))
    (list= (lambda (elt= list \.\.\.)))
    (first (lambda (pair)))
    (second (lambda (pair)))
    (third (lambda (pair)))
    (fourth (lambda (pair)))
    (fifth (lambda (pair)))
    (sixth (lambda (pair)))
    (seventh (lambda (pair)))
    (eighth (lambda (pair)))
    (ninth (lambda (pair)))
    (tenth (lambda (pair)))
    (car+cdr (lambda (pair)))
    (concatenate (lambda (list-of-lists)))
    (concatenate! (lambda (list-of-lists!)))
    (append-reverse (lambda (rev-head tail)))
    (append-reverse! (lambda (rev-head tail)))
    (zip (lambda (clist1 clist2 \.\.\.)))
    (unzip1 (lambda (list)))
    (unzip2 (lambda (list)))
    (unzip3 (lambda (list)))
    (unzip4 (lambda (list)))
    (unzip5 (lambda (list)))
    (count (lambda (pred clist1 clist2 \.\.\.)))
    (pair-fold (lambda (kons knil clist1 clist2 \.\.\.)))
    (pair-fold-right (lambda (kons knil clist1 clist2 \.\.\.)))
    (reduce (lambda (f ridentity list)))
    (reduce-right (lambda (f ridentity list)))
    (unfold (lambda (p f g seed :optional tail-gen)))
    (unfold-right (lambda (p f g seed :optional tail)))
    (append-map (lambda (f clist1 clist2 \.\.\.)))
    (append-map! (lambda (f clist1 clist2 \.\.\.)))
    (map! (lambda (f clist1 clist2 \.\.\.)))
    (map-in-order (lambda (f clist1 clist2 \.\.\.)))
    (pair-for-each (lambda (f clist1 clist2 \.\.\.)))
    (partition (lambda (pred list)))
    (partition! (lambda (pred list)))
    (take-while (lambda (pred clist)))
    (take-while! (lambda (pred list)))
    (drop-while (lambda (pred clist)))
    (span (lambda (pred clist)))
    (span! (lambda (pred list)))
    (break (lambda (pred clist)))
    (break! (lambda (pred list)))
    (list-index (lambda (pred clist1 clist2 \.\.\.)))
    (alist-cons (lambda (key datum alist)))
    (lset<= (lambda (elt= list1 \.\.\.)))
    (lset= (lambda (elt= list1 list2 \.\.\.)))
    (lset-adjoin (lambda (elt= list elt \.\.\.)))
    (lset-union (lambda (elt= list1 \.\.\.)))
    (lset-intersection (lambda (elt= list1 list2 \.\.\.)))
    (lset-difference (lambda (elt= list1 list2 \.\.\.)))
    (lset-xor (lambda (elt= list1 \.\.\.)))
    (lset-diff+intersection (lambda (elt= list1 list2 \.\.\.)))
    (lset-union! (lambda (elt= list \.\.\.)))
    (lset-intersection! (lambda (elt= list1 list2 \.\.\.)))
    (lset-difference! (lambda (elt= list1 list2 \.\.\.)))
    (lset-xor! (lambda (elt= list1 \.\.\.)))
    (lset-diff+intersection! (lambda (elt= list1 list2 \.\.\.)))
    (let (syntax nil))
    (let (syntax (name)))
    (let (syntax nil))
    (let-values (syntax (\(\(vars\ expr\)\ \.\.\.\) body \.\.\.)))
    (let*-values (syntax (\(\(vars\ expr\)\ \.\.\.\) body \.\.\.)))
    (string-null\? (lambda (s)))
    (string-every (lambda (char/char-set/pred s :optional start end)))
    (string-any (lambda (char/char-set/pred s :optional start end)))
    (string-tabulate (lambda (proc len)))
    (reverse-list->string (lambda (char-list)))
    (substring/shared (lambda (s start :optional end)))
    (string-copy! (lambda (target tstart s :optional start end)))
    (string-take (lambda (s nchars)))
    (string-drop (lambda (s nchars)))
    (string-take-right (lambda (s nchars)))
    (string-drop-right (lambda (s nchars)))
    (string-pad (lambda (s len :optional char start end)))
    (string-pad-right (lambda (s len :optional char start end)))
    (string-trim (lambda (s :optional char/char-set/pred start end)))
    (string-trim-right (lambda (s :optional char/char-set/pred start end)))
    (string-trim-both (lambda (s :optional char/char-set/pred start end)))
    (string-compare (lambda (s1 s2 proc< proc= proc> :optional start1 end1 start2 end2)))
    (string-compare-ci (lambda (s1 s2 proc< proc= proc> :optional start1 end1 start2 end2)))
    (string= (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string<> (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string< (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string<= (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string> (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string>= (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-ci= (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-ci<> (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-ci< (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-ci<= (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-ci> (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-ci>= (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-hash (lambda (s :optional bound start end)))
    (string-hash-ci (lambda (s :optional bound start end)))
    (string-prefix-length (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-suffix-length (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-prefix-length-ci (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-suffix-length-ci (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-prefix\? (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-suffix\? (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-prefix-ci\? (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-suffix-ci\? (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-index (lambda (s char/char-set/pred :optional start end)))
    (string-index-right (lambda (s char/char-set/pred :optional start end)))
    (string-skip (lambda (s char/char-set/pred :optional start end)))
    (string-skip-right (lambda (s char/char-set/pred :optional start end)))
    (string-count (lambda (s char/char-set/pred :optional start end)))
    (string-contains (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-contains-ci (lambda (s1 s2 :optional start1 end1 start2 end2)))
    (string-titlecase (lambda (s :optional start end)))
    (string-titlecase! (lambda (s :optional start end)))
    (string-upcase (lambda (s :optional start end)))
    (string-upcase! (lambda (s :optional start end)))
    (string-downcase (lambda (s :optional start end)))
    (string-downcase! (lambda (s :optional start end)))
    (string-reverse (lambda (s :optional start end)))
    (string-reverse! (lambda (s :optional start end)))
    (string-concatenate (lambda (string-list)))
    (string-concatenate/shared (lambda (string-list)))
    (string-append/shared (lambda (s \.\.\.)))
    (string-concatenate-reverse (lambda (string-list)))
    (string-concatenate-reverse/shared (lambda (string-list)))
    (string-map (lambda (proc s :optional start end)))
    (string-map! (lambda (proc s :optional start end)))
    (string-fold (lambda (kons knil s :optional start end)))
    (string-fold-right (lambda (kons knil s :optional start end)))
    (string-unfold (lambda (p f g seed :optional base make-final)))
    (string-unfold-right (lambda (p f g seed :optional base make-final)))
    (string-for-each (lambda (proc s :optional start end)))
    (string-for-each-index (lambda (proc s :optional start end)))
    (xsubstring (lambda (s from :optional to start end)))
    (string-xcopy! (lambda (target tstart s sfrom :optional sto start end)))
    (string-replace (lambda (s1 s2 start1 end1 :optional start2 end2)))
    (string-tokenize (lambda (s :optional token-set start end)))
    (string-filter (lambda (s char/char-set/pred :optional start end)))
    (string-delete (lambda (s char/char-set/pred :optional start end)))
    (string-parse-start+end (lambda (proc s args)))
    (string-parse-final-start+end (lambda (proc s args)))
    (let-string-start+end (syntax (\(start\ end\ \[rest\]\) proc-exp s-exp args-exp body \.\.\.)))
    (check-substring-spec (lambda (proc s start end)))
    (substring-spec-ok\? (lambda (s start end)))
    (make-kmp-restart-vector (lambda (s :optional c= start end)))
    (kmp-step (lambda (pat rv c i c= p-start)))
    (string-kmp-partial-search (lambda (pat rv s i :optional c= p-start s-start s-end)))
    (list->char-set (lambda (char-list :optional base-cs)))
    (list->char-set! (lambda (char-list base-cs)))
    (string->char-set (lambda (s :optional base-cs)))
    (string->char-set! (lambda (s base-cs)))
    (char-set-filter (lambda (pred char-set :optional base-cs)))
    (char-set-filter! (lambda (pred char-set base-cs)))
    (ucs-range->char-set (lambda (lower upper :optional error\? base-cs)))
    (ucs-range->char-set! (lambda (lower upper error\? base-cs)))
    (integer-range->char-set (lambda (lower upper :optional error\? base-cs)))
    (integer-range->char-set! (lambda (lower upper error\? base-cs)))
    (->char-set (lambda (x)))
    (char-set= (lambda (char-set1 \.\.\.)))
    (char-set<= (lambda (char-set1 \.\.\.)))
    (char-set-hash (lambda (char-set :optional bound)))
    (char-set-cursor (lambda (char-set)))
    (char-set-ref (lambda (char-set cursor)))
    (char-set-cursor-next (lambda (char-set cursor)))
    (end-of-char-set\? (lambda (ccursor)))
    (char-set-fold (lambda (kons knil char-set)))
    (char-set-unfold (lambda (pred fun gen seed :optional base-char-set)))
    (char-set-unfold! (lambda (pred fun gen seed base-char-set)))
    (char-set-for-each (lambda (proc char-set)))
    (char-set-map (lambda (proc char-set)))
    (char-set-size (lambda (char-set)))
    (char-set-every (lambda (pred char-set)))
    (char-set-any (lambda (pred char-set)))
    (char-set-count (lambda (pred char-set)))
    (char-set->list (lambda (char-set)))
    (char-set->string (lambda (char-set)))
    (char-set-adjoin (lambda (char-set char1 \.\.\.)))
    (char-set-adjoin! (lambda (char-set char1 \.\.\.)))
    (char-set-delete (lambda (char-set char1 \.\.\.)))
    (char-set-delete! (lambda (char-set char1 \.\.\.)))
    (char-set-union (lambda (char-set \.\.\.)))
    (char-set-union! (lambda (char-set1 char-set2 \.\.\.)))
    (char-set-intersection (lambda (char-set \.\.\.)))
    (char-set-intersection! (lambda (char-set1 char-set2 \.\.\.)))
    (char-set-difference (lambda (char-set1 char-set2 \.\.\.)))
    (char-set-difference! (lambda (char-set1 char-set2 \.\.\.)))
    (char-set-xor (lambda (char-set \.\.\.)))
    (char-set-xor! (lambda (char-set1 char-set2 \.\.\.)))
    (char-set-diff+intersection (lambda (char-set1 char-set2 \.\.\.)))
    (char-set-diff+intersection! (lambda (char-set1 char-set2 char-set3 \.\.\.)))
    (current-time (lambda (:optional time-type)))
    (current-date (lambda (:optional tz-offset)))
    (current-julian-day (lambda nil))
    (current-modified-julian-day (lambda nil))
    (time-resolution (lambda nil))
    (make-time (lambda (type nanoseconds seconds)))
    (time-type (lambda (time)))
    (time-second (lambda (time)))
    (time-nanosecond (lambda (time)))
    (set-time-type! (lambda (time type)))
    (set-time-second! (lambda (time second)))
    (set-time-nanosecond! (lambda (time nanosecond)))
    (copy-time (lambda (time)))
    (time=\? (lambda (time0 time1)))
    (time<\? (lambda (time0 time1)))
    (time<=\? (lambda (time0 time1)))
    (time>\? (lambda (time0 time1)))
    (time>=\? (lambda (time0 time1)))
    (time-difference (lambda (time0 time1)))
    (time-difference! (lambda (time0 time1)))
    (add-duration (lambda (time0 time-duration)))
    (add-duration! (lambda (time0 time-duration)))
    (subtract-duration (lambda (time0 time-duration)))
    (subtract-duration! (lambda (time0 time-duration)))
    (make-date (lambda (nanosecond second minute hour day month year zone-offset)))
    (date\? (lambda (obj)))
    (date-nanosecond (lambda (date)))
    (date-second (lambda (date)))
    (date-minute (lambda (date)))
    (date-hour (lambda (date)))
    (date-day (lambda (date)))
    (date-month (lambda (date)))
    (date-year (lambda (date)))
    (date-zone-offset (lambda (date)))
    (date-year-day (lambda (date)))
    (date-week-day (lambda (date)))
    (date-week-number (lambda (date day-of-week-starting-week)))
    (date->julian-day (lambda (date)))
    (date->modified-julian-day (lambda (date)))
    (date->time-monotonic (lambda (date)))
    (date->time-tai (lambda (date)))
    (date->time-utc (lambda (date)))
    (julian-day->date (lambda (jd :optional tz-offset)))
    (julian-day->time-monotonic (lambda (jd)))
    (julian-day->time-tai (lambda (jd)))
    (julian-day->time-utc (lambda (jd)))
    (modified-julian-day->date (lambda (jd :optional tz-offset)))
    (modified-julian-day->time-monotonic (lambda (jd)))
    (modified-julian-day->time-tai (lambda (jd)))
    (modified-julian-day->time-utc (lambda (jd)))
    (time-monotonic->date (lambda (time :optional tz-offset)))
    (time-monotonic->julian-day (lambda (time)))
    (time-monotonic->modified-julian-day (lambda (time)))
    (time-monotonic->time-tai (lambda (time)))
    (time-monotonic->time-tai! (lambda (time)))
    (time-monotonic->time-utc (lambda (time)))
    (time-monotonic->time-utc! (lambda (time)))
    (time-tai->date (lambda (time :optional tz-offset)))
    (time-tai->julian-day (lambda (time)))
    (time-tai->modified-julian-day (lambda (time)))
    (time-tai->time-monotonic (lambda (time)))
    (time-tai->time-monotonic! (lambda (time)))
    (time-tai->time-utc (lambda (time)))
    (time-tai->time-utc! (lambda (time)))
    (time-utc->date (lambda (time :optional tz-offset)))
    (time-utc->julian-day (lambda (time)))
    (time-utc->modified-julian-day (lambda (time)))
    (time-utc->time-monotonic (lambda (time)))
    (time-utc->time-monotonic! (lambda (time)))
    (time-utc->time-tai (lambda (time)))
    (time-utc->time-tai! (lambda (time)))
    (date->string (lambda (date :optional format-string)))
    (string->date (lambda (string template-string)))
    (random-integer (lambda (n)))
    (random-real (lambda nil))
    (make-random-source (lambda nil))
    (random-source\? (lambda (obj)))
    (random-source-state-ref (lambda (s)))
    (random-source-state-set! (lambda (s state)))
    (random-source-randomize! (lambda (s)))
    (random-source-pseudo-randomize! (lambda (s i j)))
    (random-source-make-integers (lambda (s)))
    (random-source-make-reals (lambda (s :optional unit)))
    (declare-bundle! (lambda (bundle-specifier association-list)))
    (save-bundle! (lambda (bundle-specifier)))
    (load-bundle! (lambda (bundle-specifier)))
    (localized-template (lambda (package-name message-template-name)))
    (format (lambda (format-string args)))
    (args-fold (lambda (args options unrecognized-proc operand-proc :rest seeds)))
    (option (lambda (names require-arg\? optional-arg\? processor)))
    (option\? (lambda (obj)))
    (option-names (lambda (option)))
    (option-required-arg\? (lambda (option)))
    (option-optional-arg\? (lambda (option)))
    (option-processor (lambda nil))
    (do-ec (syntax (qualifier \.\.\. body)))
    (list-ec (syntax (qualifier \.\.\. body)))
    (append-ec (syntax (qualifier \.\.\. body)))
    (string-ec (syntax (qualifier \.\.\. body)))
    (string-append-ec (syntax (qualifier \.\.\. body)))
    (vector-ec (syntax (qualifier \.\.\. body)))
    (vector-of-length-ec (syntax (k qualifier \.\.\. body)))
    (sum-ec (syntax (qualifier \.\.\. body)))
    (product-ec (syntax (qualifier \.\.\. body)))
    (min-ec (syntax (qualifier \.\.\. body)))
    (max-ec (syntax (qualifier \.\.\. body)))
    (any\?-ec (syntax (qualifier \.\.\. test)))
    (every\?-ec (syntax (qualifier \.\.\. test)))
    (first-ec (syntax (default qualifier \.\.\. body)))
    (last-ec (syntax (default qualifier \.\.\. body)))
    (fold-ec (syntax (seed qualifier \.\.\. expr proc)))
    (fold3-ec (syntax (seed qualifier \.\.\. expr init proc)))
    (vector-unfold (lambda (f length seed \.\.\.)))
    (vector-unfold-right (lambda (f length seed \.\.\.)))
    (vector-reverse-copy (lambda (vec :optional start end)))
    (vector-append (lambda (vec \.\.\.)))
    (vector-concatenate (lambda (list-of-vectors)))
    (vector-empty\? (lambda (vec)))
    (vector= (lambda (elt= vec \.\.\.)))
    (vector-fold (lambda (kons knil vec1 vec2 \.\.\.)))
    (vector-fold-right (lambda (kons knil vec1 vec2 \.\.\.)))
    (vector-map (lambda (f vec1 vec2 \.\.\.)))
    (vector-map! (lambda (f vec1 vec2 \.\.\.)))
    (vector-for-each (lambda (f vec1 vec2 \.\.\.)))
    (vector-count (lambda (f vec1 vec2 \.\.\.)))
    (vector-index (lambda (pred vec1 vec2 \.\.\.)))
    (vector-index-right (lambda (pred vec1 vec2 \.\.\.)))
    (vector-skip (lambda (pred vec1 vec2 \.\.\.)))
    (vector-skip-right (lambda (pred vec1 vec2 \.\.\.)))
    (vector-binary-search (lambda (vec value cmp :optional start end)))
    (vector-any (lambda (pred vec1 vec2 \.\.\.)))
    (vector-every (lambda (pred vec1 vec2 \.\.\.)))
    (vector-swap! (lambda (vec i j)))
    (vector-reverse! (lambda (vec :optional start end)))
    (vector-copy! (lambda (target tstart source :optional sstart send)))
    (vector-reverse-copy! (lambda (target tstart source :optional sstart send)))
    (reverse-vector->list (lambda (vec :optional start end)))
    (reverse-list->vector (lambda (list :optional start end)))
    (require-extension (syntax (clause \.\.\.)))
    (lognot (lambda (n)))
    (bitwise-not (lambda (n)))
    (logand (lambda (n \.\.\.)))
    (bitwise-and (lambda (n \.\.\.)))
    (logior (lambda (n \.\.\.)))
    (bitwise-ior (lambda (n \.\.\.)))
    (logxor (lambda (n \.\.\.)))
    (bitwise-xor (lambda (n \.\.\.)))
    (bitwise-if (lambda (mask n0 n1)))
    (logtest (lambda (mask n)))
    (any-bits-set\? (lambda (mask n)))
    (logcount (lambda (n)))
    (bit-count (lambda (n)))
    (integer-length (lambda (n)))
    (log2-binary-factors (lambda (n)))
    (first-set-bit (lambda (n)))
    (logbit\? (lambda (index n)))
    (bit-set\? (lambda (index n)))
    (copy-bit (lambda (index n bit)))
    (bit-field (lambda (n start end)))
    (copy-bit-field (lambda (to from start end)))
    (ash (lambda (n count)))
    (arithmetic-shift (lambda (n count)))
    (rotate-bit-field (lambda (n count start end)))
    (reverse-bit-field (lambda (n start end)))
    (integer->list (lambda (n :optional len)))
    (list->integer (lambda (lis)))
    (booleans->integer (lambda (bool \.\.\.)))
    (get-environment-variable (lambda (name)))
    (get-environment-variables (lambda nil))
    (read-u8 (lambda (:optional port endian)))
    (read-u16 (lambda (:optional port endian)))
    (read-u32 (lambda (:optional port endian)))
    (read-u64 (lambda (:optional port endian)))
    (read-s8 (lambda (:optional port endian)))
    (read-s16 (lambda (:optional port endian)))
    (read-s32 (lambda (:optional port endian)))
    (read-s64 (lambda (:optional port endian)))
    (read-uint (lambda (size :optional port endian)))
    (read-sint (lambda (size :optional port endian)))
    (read-ber-integer (lambda (:optional port)))
    (write-u8 (lambda (val :optional port endian)))
    (write-u16 (lambda (val :optional port endian)))
    (write-u32 (lambda (val :optional port endian)))
    (write-u64 (lambda (val :optional port endian)))
    (write-s8 (lambda (val :optional port endian)))
    (write-s16 (lambda (val :optional port endian)))
    (write-s32 (lambda (val :optional port endian)))
    (write-s64 (lambda (val :optional port endian)))
    (write-uint (lambda (size val :optional port endian)))
    (write-sint (lambda (size val :optional port endian)))
    (write-ber-integer (lambda (val :optional port)))
    (read-f16 (lambda (:optional port endian)))
    (read-f32 (lambda (:optional port endian)))
    (read-f64 (lambda (:optional port endian)))
    (write-f16 (lambda (val :optional port endian)))
    (write-f32 (lambda (val :optional port endian)))
    (write-f64 (lambda (val :optional port endian)))
    (get-u8 (lambda (uv pos :optional endian)))
    (get-u16 (lambda (uv pos :optional endian)))
    (get-u32 (lambda (uv pos :optional endian)))
    (get-u64 (lambda (uv pos :optional endian)))
    (get-s8 (lambda (uv pos :optional endian)))
    (get-s16 (lambda (uv pos :optional endian)))
    (get-s32 (lambda (uv pos :optional endian)))
    (get-s64 (lambda (uv pos :optional endian)))
    (get-f16 (lambda (uv pos :optional endian)))
    (get-f32 (lambda (uv pos :optional endian)))
    (get-f64 (lambda (uv pos :optional endian)))
    (get-u16be (lambda (uv pos)))
    (get-u16le (lambda (uv pos)))
    (get-u32be (lambda (uv pos)))
    (get-u32le (lambda (uv pos)))
    (get-u64be (lambda (uv pos)))
    (get-u64le (lambda (uv pos)))
    (get-s16be (lambda (uv pos)))
    (get-s16le (lambda (uv pos)))
    (get-s32be (lambda (uv pos)))
    (get-s32le (lambda (uv pos)))
    (get-s64be (lambda (uv pos)))
    (get-s64le (lambda (uv pos)))
    (get-f16be (lambda (uv pos)))
    (get-f16le (lambda (uv pos)))
    (get-f32be (lambda (uv pos)))
    (get-f32le (lambda (uv pos)))
    (get-f64be (lambda (uv pos)))
    (get-f64le (lambda (uv pos)))
    (put-u8! (lambda (uv pos val :optional endian)))
    (put-u16! (lambda (uv pos val :optional endian)))
    (put-u32! (lambda (uv pos val :optional endian)))
    (put-u64! (lambda (uv pos val :optional endian)))
    (put-s8! (lambda (uv pos val :optional endian)))
    (put-s16! (lambda (uv pos val :optional endian)))
    (put-s32! (lambda (uv pos val :optional endian)))
    (put-s64! (lambda (uv pos val :optional endian)))
    (put-f16! (lambda (uv pos val :optional endian)))
    (put-f32! (lambda (uv pos val :optional endian)))
    (put-f64! (lambda (uv pos val :optional endian)))
    (put-u16be! (lambda (uv pos val)))
    (put-u16le! (lambda (uv pos val)))
    (put-u32be! (lambda (uv pos val)))
    (put-u32le! (lambda (uv pos val)))
    (put-u64be! (lambda (uv pos val)))
    (put-u64le! (lambda (uv pos val)))
    (put-s16be! (lambda (uv pos val)))
    (put-s16le! (lambda (uv pos val)))
    (put-s32be! (lambda (uv pos val)))
    (put-s32le! (lambda (uv pos val)))
    (put-s64be! (lambda (uv pos val)))
    (put-s64le! (lambda (uv pos val)))
    (put-f16be! (lambda (uv pos val)))
    (put-f16le! (lambda (uv pos val)))
    (put-f32be! (lambda (uv pos val)))
    (put-f32le! (lambda (uv pos val)))
    (put-f64be! (lambda (uv pos val)))
    (put-f64le! (lambda (uv pos val)))
    (pack (lambda (template list :key (:output) (:to-string\?))))
    (unpack (lambda (template :key (:input) (:from-string))))
    (unpack-skip (lambda (template :key (:input))))
    (make-packer (lambda (template)))
    (job\? (lambda (obj)))
    (job-status (lambda (job)))
    (job-result (lambda (job)))
    (job-wait (lambda (job :optional timeout timeout-val)))
    (job-acknowledge-time (lambda (job)))
    (job-start-time (lambda (job)))
    (job-finish-time (lambda (job)))
    (make-thread-pool (lambda (size :key (\(max-backlog\ 0\)))))
    (thread-pool-results (lambda (pool)))
    (thread-pool-shut-down\? (lambda (pool)))
    (add-job! (lambda (pool thunk :optional)))
    (wait-all (lambda (pool :optional)))
    (terminate-all! (lambda (pool :key)))
    (bcrypt-hashpw (lambda (password :optional setting)))
    (bcrypt-gensalt (lambda (&key prefix count entropy-source)))
    (dbi-connect (lambda (dsn :key (username) (password))))
    (dbi-list-drivers (lambda nil))
    (dbi-make-driver (lambda (driver-name)))
    (dbi-parse-dsn (lambda (data-source-name)))
    (dbi-prepare-sql (lambda (connection sql)))
    (dbm-type->class (lambda (dbmtype)))
    (gdbm-open (lambda (path :optional size rwmode fmode error-callback)))
    (gdbm-close (lambda (gdbm-object)))
    (gdbm-closed\? (lambda (gdbm-object)))
    (gdbm-store (lambda (key value :optional flag)))
    (gdbm-fetch (lambda (gdbm-object key)))
    (gdbm-delete (lambda (gdbm-object key)))
    (gdbm-firstkey (lambda (gdbm-object)))
    (gdbm-nextkey (lambda (gdbm-object key)))
    (gdbm-reorganize (lambda (gdbm-object)))
    (gdbm-sync (lambda (gdbm-object)))
    (gdbm-exists\? (lambda (gdbm-object key)))
    (gdbm-strerror (lambda (errno)))
    (gdbm-setopt (lambda (gdbm-object option value)))
    (gdbm-version (lambda nil))
    (gdbm-errno (lambda nil))
    (ndbm-open (lambda (path flags mode)))
    (ndbm-close (lambda (ndbm-object)))
    (ndbm-closed\? (lambda (ndbm-object)))
    (ndbm-store (lambda (ndbm-object key content :optional flag)))
    (ndbm-fetch (lambda (ndbm-object key)))
    (ndbm-delete (lambda (ndbm-object key)))
    (ndbm-firstkey (lambda (ndbm-object)))
    (ndbm-nextkey (lambda (ndbm-object)))
    (ndbm-error (lambda (ndbm-object)))
    (ndbm-clear-error (lambda (ndbm-object)))
    (odbm-init (lambda (path)))
    (odbm-close (lambda nil))
    (odbm-store (lambda (key value)))
    (odbm-fetch (lambda (key)))
    (odbm-delete (lambda (key)))
    (odbm-firstkey (lambda nil))
    (odbm-nextkey (lambda (key)))
    (file-filter (lambda (proc :key (input) (output) (temporary-file) (keep-output\?))))
    (current-directory (lambda (:optional new-directory)))
    (home-directory (lambda (:optional user)))
    (directory-list (lambda (path :key (children\?) (add-path\?) (filter) (filter-add-path\?))))
    (directory-list2 (lambda (path :key (children\?) (add-path\?) (filter) (follow-link\?))))
    (directory-fold (lambda (path proc seed :key (lister) (follow-link\?))))
    (make-directory* (lambda (name :optional perm)))
    (create-directory* (lambda (name :optional perm)))
    (remove-directory* (lambda (name)))
    (delete-directory* (lambda (name)))
    (copy-directory* (lambda (src dst :key (if-exists) (backup-suffix) (safe) (keep-timestamp) (keep-mode) (follow-link\?))))
    (create-directory-tree (lambda (dir spec)))
    (check-directory-tree (lambda (dir spec)))
    (build-path (lambda (base-path component \.\.\.)))
    (absolute-path\? (lambda (path)))
    (relative-path\? (lambda (path)))
    (expand-path (lambda (path)))
    (resolve-path (lambda (path)))
    (simplify-path (lambda (path)))
    (decompose-path (lambda (path)))
    (path-extension (lambda (path)))
    (path-sans-extension (lambda (path)))
    (path-swap-extension (lambda (path newext)))
    (find-file-in-paths (lambda (name :key (paths) (pred))))
    (null-device (lambda nil))
    (console-device (lambda nil))
    (file-type (lambda (path :key (follow-link\?))))
    (file-perm (lambda (path :key (follow-link\?))))
    (file-mode (lambda (path :key (follow-link\?))))
    (file-ino (lambda (path :key (follow-link\?))))
    (file-dev (lambda (path :key (follow-link\?))))
    (file-rdev (lambda (path :key (follow-link\?))))
    (file-nlink (lambda (path :key (follow-link\?))))
    (file-uid (lambda (path :key (follow-link\?))))
    (file-gid (lambda (path :key (follow-link\?))))
    (file-size (lambda (path :key (follow-link\?))))
    (file-atime (lambda (path :key (follow-link\?))))
    (file-mtime (lambda (path :key (follow-link\?))))
    (file-ctime (lambda (path :key (follow-link\?))))
    (file-is-readable\? (lambda (path)))
    (file-is-writable\? (lambda (path)))
    (file-is-executable\? (lambda (path)))
    (file-is-symlink\? (lambda (path)))
    (file-eq\? (lambda (path1 path2)))
    (file-eqv\? (lambda (path1 path2)))
    (file-equal\? (lambda (path1 path2)))
    (touch-file (lambda (path :key)))
    (touch-files (lambda (paths :key)))
    (copy-file (lambda (src dst :key (if-exists) (backup-suffix) (safe) (keep-timestamp) (keep-mode) (follow-link\?))))
    (move-file (lambda (src dst :key (if-exists) (backup-suffix))))
    (remove-files (lambda (paths)))
    (delete-files (lambda (paths)))
    (file->string (lambda (filename options \.\.\.)))
    (file->list (lambda (reader filename options \.\.\.)))
    (file->string-list (lambda (filename options \.\.\.)))
    (file->sexp-list (lambda (filename options \.\.\.)))
    (with-lock-file (lambda (lock-name thunk :key (type) (retry-interval) (@))))
    (mt-random-set-seed! (lambda (mt seed)))
    (mt-random-get-state (lambda (mt)))
    (mt-random-set-state! (lambda (mt state)))
    (mt-random-real (lambda (mt)))
    (mt-random-real0 (lambda (mt)))
    (mt-random-integer (lambda (mt range)))
    (mt-random-fill-u32vector! (lambda (mt u32vector)))
    (mt-random-fill-f32vector! (lambda (mt f32vector)))
    (mt-random-fill-f64vector! (lambda (mt f64vector)))
    (sys-message-box (lambda (window message :optional caption flags)))
    (sys-alloc-console (lambda nil))
    (sys-free-console (lambda nil))
    (sys-generate-console-ctrl-event (lambda (event pgid)))
    (sys-get-console-cp (lambda nil))
    (sys-get-console-output-cp (lambda nil))
    (sys-set-console-cp (lambda (codepage)))
    (sys-set-console-output-cp (lambda (codepage)))
    (sys-get-console-cursor-info (lambda (handle)))
    (sys-set-console-cursor-info (lambda (handle size visible)))
    (sys-set-console-cursor-position (lambda (handle x y)))
    (sys-get-console-mode (lambda (handle)))
    (sys-set-console-mode (lambda (handle mode)))
    (sys-create-console-screen-buffer (lambda (desired-access share-mode inheritable)))
    (sys-set-console-active-screen-buffer (lambda (handle)))
    (sys-scroll-console-screen-buffer (lambda (handle scroll-rectangle clip-rectangle x y fill)))
    (sys-get-console-screen-buffer-info (lambda (handle)))
    (sys-get-largest-console-window-size (lambda (handle)))
    (sys-set-screen-buffer-size (lambda (handle x y)))
    (sys-get-number-of-console-input-events (lambda (handle)))
    (sys-get-number-of-console-mouse-buttons (lambda nil))
    (sys-peek-console-input (lambda (handle)))
    (sys-read-console-input (lambda (handle)))
    (sys-read-console (lambda (handle buf)))
    (sys-read-console-output (lambda (handle buf w h x y region)))
    (sys-read-console-output-attribute (lambda (handle buf x y)))
    (sys-read-console-output-character (lambda (handle len x y)))
    (sys-set-console-text-attribute (lambda (handle attr)))
    (sys-set-console-window-info (lambda (handle absolute window)))
    (sys-write-console (lambda (handle string)))
    (sys-write-console-output-character (lambda (handle string x y)))
    (sys-get-console-title (lambda nil))
    (sys-get-std-handle (lambda (which)))
    (sys-set-std-handle (lambda (which handle)))
    (rfc822-read-headers (lambda (iport :key (strict\?) (reader))))
    (rfc822-header->list (lambda (iport :key (strict\?) (reader))))
    (rfc822-header-ref (lambda (header-list field-name :optional default)))
    (rfc822-next-token (lambda (iport :optional tokenizer-specs)))
    (rfc822-field->tokens (lambda (field :optional tokenizer-specs)))
    (rfc822-skip-cfws (lambda (iport)))
    (rfc822-atom (lambda (iport)))
    (rfc822-dot-atom (lambda (iport)))
    (rfc822-quoted-string (lambda (iport)))
    (rfc822-parse-date (lambda (string)))
    (rfc822-date->date (lambda (string)))
    (rfc822-write-headers (lambda (headers :key (output) (continue) (check))))
    (date->rfc822-date (lambda (date)))
    (base64-encode (lambda (:key (line-width))))
    (base64-encode-string (lambda (string :key (line-width))))
    (base64-decode (lambda nil))
    (base64-decode-string (lambda (string)))
    (parse-cookie-string (lambda (string :optional version)))
    (construct-cookie-string (lambda (specs :optional version)))
    (call-with-ftp-connection (lambda (host proc :key (passive) (port) (username) (password) (account) (log-drain))))
    (ftp-transfer-type (lambda (conn)))
    (ftp-passive\? (lambda (conn)))
    (ftp-login (lambda (host :key (passive) (port) (username) (password) (account) (log-drain))))
    (ftp-quit (lambda (conn)))
    (ftp-chdir (lambda (conn dirname)))
    (ftp-remove (lambda (conn path)))
    (ftp-help (lambda (conn :optional option \.\.\.)))
    (ftp-mkdir (lambda (conn dirname)))
    (ftp-current-directory (lambda (conn)))
    (ftp-site (lambda (conn arg)))
    (ftp-rmdir (lambda (conn dirname)))
    (ftp-stat (lambda (conn :optional pathname)))
    (ftp-system (lambda (conn)))
    (ftp-size (lambda (conn path)))
    (ftp-mdtm (lambda (conn path)))
    (ftp-mtime (lambda (conn path :optional local-time\?)))
    (ftp-noop (lambda (conn)))
    (ftp-list (lambda (conn :optional path)))
    (ftp-get (lambda (conn path :key (sink) (flusher))))
    (ftp-put (lambda (conn from-file :optional to-file)))
    (ftp-put-unique (lambda (conn from-file)))
    (ftp-rename (lambda (conn from-name to-name)))
    (http-get (lambda (server request-uri :key (sink) (flusher) (redirect-handler) (secure) (\.\.\.))))
    (http-head (lambda (server request-uri :key (redirect-handler) (secure) (\.\.\.))))
    (http-post (lambda (server request-uri body :key (sink) (flusher) (redirect-handler) (secure) (\.\.\.))))
    (http-put (lambda (server request-uri body :key (sink) (flusher) (redirect-handler) (secure) (\.\.\.))))
    (http-delete (lambda (server request-uri :key (sink) (flusher) (redirect-handler) (secure) (\.\.\.))))
    (http-compose-query (lambda (path params :optional encoding)))
    (http-compose-form-data (lambda (params port :optional encoding)))
    (http-secure-connection-available\? (lambda nil))
    (ip-version (lambda (packet offset)))
    (ip-header-length (lambda (packet offset)))
    (ip-protocol (lambda (packet offset)))
    (ip-source-address (lambda (packet offset)))
    (ip-destination-address (lambda (packet offset)))
    (icmp4-fill-echo! (lambda (buffer ident sequence data)))
    (icmp4-fill-checksum! (lambda (buffer size)))
    (icmp6-fill-echo! (lambda (buffer ident sequence data)))
    (icmp-packet-type (lambda (buffer offset)))
    (icmp-packet-code (lambda (buffer offset)))
    (icmp-packet-ident (lambda (buffer offset)))
    (icmp-packet-sequence (lambda (buffer offsetj)))
    (icmp4-describe-packet (lambda (buffer offset)))
    (icmp6-describe-packet (lambda (buffer offset)))
    (icmp4-message-type->string (lambda (type)))
    (icmp4-unreach-code->string (lambda (code)))
    (icmp4-redirect-code->string (lambda (code)))
    (icmp4-router-code->string (lambda (code)))
    (icmp4-exceeded-code->string (lambda (code)))
    (icmp4-parameter-code->string (lambda (code)))
    (icmp4-security-code->string (lambda (code)))
    (icmp6-message-type->string (lambda (type)))
    (icmp6-unreach-code->string (lambda (code)))
    (icmp6-exceeded-code->string (lambda (code)))
    (icmp6-parameter-code->string (lambda (code)))
    (parse-json (lambda (:optional input-port)))
    (parse-json-string (lambda (str)))
    (construct-json (lambda (obj :optional output-port)))
    (construct-json-string (lambda (obj)))
    (md5-digest (lambda nil))
    (md5-digest-string (lambda (string)))
    (mime-parse-version (lambda (field)))
    (mime-parse-content-type (lambda (field)))
    (mime-parse-content-disposition (lambda (field)))
    (mime-parse-parameters (lambda (:optional iport)))
    (mime-compose-parameters (lambda (params :optional oport &key start-column)))
    (mime-decode-word (lambda (word)))
    (mime-decode-text (lambda (text)))
    (mime-encode-word (lambda (word :key (charset) (transfer-encoding))))
    (mime-encode-text (lambda (text :key (charset) (transfer-encoding) (line-width) (start-column) (force))))
    (mime-parse-message (lambda (port headers handler)))
    (mime-retrieve-body (lambda (part-info xport outp)))
    (mime-body->string (lambda (part-info xport)))
    (mime-body->file (lambda (part-info xport filename)))
    (mime-compose-message (lambda (parts :optional port &key boundary)))
    (mime-compose-message-string (lambda (parts &key boundary)))
    (mime-make-boundary (lambda nil))
    (quoted-printable-encode (lambda (:key (line-width) (binary))))
    (quoted-printable-encode-string (lambda (string :key (line-width) (binary))))
    (quoted-printable-decode (lambda nil))
    (quoted-printable-decode-string (lambda (string)))
    (sha1-digest (lambda nil))
    (sha224-digest (lambda nil))
    (sha256-digest (lambda nil))
    (sha384-digest (lambda nil))
    (sha512-digest (lambda nil))
    (sha1-digest-string (lambda (string)))
    (sha224-digest-string (lambda (string)))
    (sha256-digest-string (lambda (string)))
    (sha384-digest-string (lambda (string)))
    (sha512-digest-string (lambda (string)))
    (uri-parse (lambda (uri)))
    (uri-scheme&specific (lambda (uri)))
    (uri-decompose-hierarchical (lambda (specific)))
    (uri-decompose-authority (lambda (authority)))
    (uri-compose (lambda (:key (scheme) (userinfo) (host) (port) (authority) (path) (path*) (query) (fragment) (specific))))
    (uri-merge (lambda (base-uri relative-uri relative-uri2 \.\.\.)))
    (uri-decode (lambda (:key (:cgi-decode))))
    (uri-decode-string (lambda (string :key (:cgi-decode) (:encoding))))
    (uri-encode (lambda (:key (:noescape))))
    (uri-encode-string (lambda (string :key (:noescape) (:encoding))))
    (open-deflating-port (lambda (drain :key (compression-level) (buffer-size) (window-bits) (memory-level) (strategy) (dictionary) (owner\?))))
    (open-inflating-port (lambda (source :key (buffer-size) (window-bits) (dictionary) (owner\?))))
    (zstream-total-in (lambda (xflating-port)))
    (zstream-total-out (lambda (xflating-port)))
    (zstream-adler32 (lambda (xflating-port)))
    (zstream-data-type (lambda (xflating-port)))
    (zstream-params-set! (lambda (deflating-port :key (compression-level) (strategy))))
    (zstream-dictionary-adler32 (lambda (deflating-port)))
    (deflating-port-full-flush (lambda (deflating-port)))
    (inflate-sync (lambda (inflating-port)))
    (zlib-version (lambda nil))
    (deflate-string (lambda (string options \.\.\.)))
    (inflate-string (lambda (string options \.\.\.)))
    (gzip-encode-string (lambda (string options \.\.\.)))
    (gzip-decode-string (lambda (string options \.\.\.)))
    (crc32 (lambda (string :optional checksum)))
    (adler32 (lambda (string :optional checksum)))
    (make-empty-attlist (lambda nil))
    (attlist-add (lambda (attlist name-value)))
    (attlist-null\? (lambda nil))
    (attlist-remove-top (lambda (attlist)))
    (attlist->alist (lambda (attlist)))
    (attlist-fold (lambda nil))
    (make-xml-token (lambda (kind head)))
    (xml-token\? (lambda (token)))
    (xml-token-kind (syntax (token)))
    (xml-token-head (syntax (token)))
    (ssax:skip-S (lambda (port)))
    (ssax:ncname-starting-char\? (lambda (a-char)))
    (ssax:read-NCName (lambda (port)))
    (ssax:read-QName (lambda (port)))
    (ssax:read-markup-token (lambda (port)))
    (ssax:skip-pi (lambda (port)))
    (ssax:read-pi-body-as-string (lambda (port)))
    (ssax:skip-internal-dtd (lambda (port)))
    (ssax:read-cdata-body (lambda (port str-handler seed)))
    (ssax:read-char-ref (lambda (port)))
    (ssax:handle-parsed-entity (lambda (port name entities content-handler str-handler seed)))
    (ssax:read-attributes (lambda (port entities)))
    (ssax:resolve-name (lambda (port unres-name namespaces apply-default-ns\?)))
    (ssax:uri-string->symbol (lambda (uri-str)))
    (ssax:complete-start-tag (lambda (tag port elems entities namespaces)))
    (ssax:read-external-id (lambda (port)))
    (ssax:scan-Misc (lambda (port)))
    (ssax:read-char-data (lambda (port expect-eof\? str-handler seed)))
    (ssax:assert-token (lambda (token kind gi error-cont)))
    (ssax:make-pi-parser (syntax (my-pi-handlers)))
    (ssax:make-elem-parser (syntax (my-new-level-seed my-finish-element my-char-data-handler my-pi-handlers)))
    (ssax:make-parser (syntax (user-handler-tag user-handler-proc \\\.\\\.\\\.)))
    (ssax:reverse-collect-str (lambda (fragments)))
    (ssax:reverse-collect-str-drop-ws (lambda (fragments)))
    (ssax:xml->sxml (lambda (port namespace-prefix-assig)))
    (nodeset\? (lambda (x)))
    (as-nodeset (lambda (x)))
    (sxml:element\? (lambda (obj)))
    (ntype-names\?\? (lambda (crit)))
    (ntype\?\? (lambda (crit)))
    (ntype-namespace-id\?\? (lambda (ns-id)))
    (sxml:invert (lambda (pred)))
    (node-eq\? (lambda (other)))
    (node-equal\? (lambda (other)))
    (node-pos (lambda (n)))
    (sxml:filter (lambda (pred\?)))
    (take-until (lambda (pred\?)))
    (take-after (lambda (pred\?)))
    (map-union (lambda (proc lst)))
    (node-reverse (lambda (node-or-nodeset)))
    (node-trace (lambda (title)))
    (select-kids (lambda (test-pred\?)))
    (node-self (lambda (pred)))
    (node-join (lambda nil))
    (node-reduce (lambda nil))
    (node-or (lambda nil))
    (node-closure (lambda (test-pred\?)))
    (sxpath (lambda (abbrpath)))
    (if-sxpath (lambda (path)))
    (if-car-sxpath (lambda (path)))
    (car-sxpath (lambda (path)))
    (sxml:id-alist (lambda (node)))
    (sxml:string (lambda (object)))
    (sxml:boolean (lambda (object)))
    (sxml:number (lambda (obj)))
    (sxml:string-value (lambda (node)))
    (sxml:node\? (lambda (node)))
    (sxml:attr-list (lambda (obj)))
    (sxml:id (lambda (id-index)))
    (sxml:equality-cmp (lambda (bool-op number-op string-op)))
    (sxml:equal\? (lambda (a b)))
    (sxml:not-equal\? (lambda (a b)))
    (sxml:relational-cmp (lambda (op)))
    (sxml:attribute (lambda (test-pred\?)))
    (sxml:child (lambda (test-pred\?)))
    (sxml:parent (lambda (test-pred\?)))
    (sxml:ancestor (lambda (test-pred\?)))
    (sxml:ancestor-or-self (lambda (test-pred\?)))
    (sxml:descendant (lambda (test-pred\?)))
    (sxml:descendant-or-self (lambda (test-pred\?)))
    (sxml:following (lambda (test-pred\?)))
    (sxml:following-sibling (lambda (test-pred\?)))
    (sxml:namespace (lambda (test-pred\?)))
    (sxml:preceding (lambda (test-pred\?)))
    (sxml:preceding-sibling (lambda (test-pred\?)))
    (sxml:child-nodes (lambda (nodeset)))
    (sxml:child-elements (lambda (nodeset)))
    (sxml:empty-element\? (lambda (obj)))
    (sxml:shallow-normalized\? (lambda (obj)))
    (sxml:normalized\? (lambda (obj)))
    (sxml:shallow-minimized\? (lambda (obj)))
    (sxml:minimized\? (lambda (obj)))
    (sxml:name (lambda (obj)))
    (sxml:element-name (lambda (obj)))
    (sxml:node-name (lambda (obj)))
    (sxml:ncname (lambda (obj)))
    (sxml:name->ns-id (lambda (sxml-name)))
    (sxml:content (lambda (obj)))
    (sxml:content-raw (lambda (obj)))
    (sxml:attr-list-node (lambda (obj)))
    (sxml:attr-as-list (lambda (obj)))
    (sxml:aux-list-node (lambda (obj)))
    (sxml:aux-as-list (lambda (obj)))
    (sxml:attr-list-u (lambda (obj)))
    (sxml:aux-list (lambda (obj)))
    (sxml:aux-list-u (lambda (obj)))
    (sxml:aux-node (lambda (obj aux-name)))
    (sxml:aux-nodes (lambda (obj aux-name)))
    (sxml:attr (lambda (obj attr-name)))
    (sxml:num-attr (lambda (obj attr-name)))
    (sxml:attr-u (lambda (obj attr-name)))
    (sxml:ns-list (lambda (obj)))
    (sxml:ns-id->nodes (lambda (obj namespace-id)))
    (sxml:ns-id->uri (lambda (obj namespace-id)))
    (sxml:ns-uri->id (lambda (obj uri)))
    (sxml:ns-id (lambda (ns-assoc)))
    (sxml:ns-uri (lambda (ns-assoc)))
    (sxml:ns-prefix (lambda (ns-assoc)))
    (sxml:change-content (lambda (obj new-content)))
    (sxml:change-content! (lambda (obj new-content)))
    (sxml:change-attrlist (lambda (obj new-attrlist)))
    (sxml:change-attrlist! (lambda (obj new-attrlist)))
    (sxml:change-name (lambda (obj new-name)))
    (sxml:change-name! (lambda (obj new-name)))
    (sxml:add-attr (lambda (obj attr)))
    (sxml:add-attr! (lambda (obj attr)))
    (sxml:change-attr (lambda (obj attr)))
    (sxml:change-attr! (lambda (obj attr)))
    (sxml:set-attr (lambda (obj attr)))
    (sxml:set-attr! (lambda (obj attr)))
    (sxml:add-aux (lambda (obj aux-node)))
    (sxml:add-aux! (lambda (obj aux-node)))
    (sxml:squeeze (lambda (obj)))
    (sxml:squeeze! (lambda (obj)))
    (sxml:clean (lambda (obj)))
    (sxml:add-parents (lambda (obj)))
    (sxml:node-parent (lambda (rootnode)))
    (sxml:lookup (lambda (id index)))
    (sxml:clean-feed (lambda nil))
    (sxml:attr->xml (lambda (attr)))
    (sxml:string->xml (lambda (string)))
    (sxml:sxml->xml (lambda (tree)))
    (sxml:attr->html (lambda (attr)))
    (sxml:string->html (lambda (string)))
    (sxml:non-terminated-html-tag\? (lambda (tag)))
    (sxml:sxml->html (lambda (tree)))
    (srl:sxml->xml (lambda (sxml-obj :optional port-or-filename)))
    (srl:sxml->xml-noindent (lambda (sxml-obj :optional port-or-filename)))
    (srl:sxml->html (lambda (sxml-obj :optional port-or-filename)))
    (srl:sxml->html-noindent (lambda (sxml-obj :optional port-or-filename)))
    (srl:parameterizable (lambda (sxml-obj :optional port-or-filename params*)))
    (srl:sxml->string (lambda (sxml-obj cdata-section-elements indent method ns-prefix-assig omit-xml-declaration\? standalone version)))
    (srl:display-sxml (lambda (sxml->obj port-or-filename cdata-section-elements indent method ns-prefix-assig omit-xml-declaration\? standalone version)))
    (make-csv-reader (lambda (separator :optional)))
    (make-csv-writer (lambda (separator :optional newline)))
    (diff (lambda (src-a src-b :key (reader) (eq-fn))))
    (diff-report (lambda (src-a src-b :key (reader) (eq-fn) (writer))))
    (textdomain (lambda (domain-name :optional locale dirs cdir cached\? lookup-cached\?)))
    (gettext (lambda (msg-id)))
    (ngettext (lambda (msg-id :optional msg-id2 num)))
    (bindtextdomain (lambda (domain dirs)))
    (dgettext (lambda (domain msg-id)))
    (dcgettext (lambda (domain msg-id locale)))
    (make-gettext (lambda (:optional domain locale dirs gettext-cached\? lookup-cached\?)))
    (html-escape (lambda nil))
    (html-escape-string (lambda (string)))
    (html-doctype (lambda (:key (type))))
    (find-string-from-port\? (lambda (str in-port :optional max-no-chars)))
    (peek-next-char (lambda (:optional port)))
    (assert-curr-char (lambda (char-list string :optional port)))
    (skip-until (lambda (char-list/number :optional port)))
    (skip-while (lambda (char-list :optional port)))
    (next-token (lambda (prefix-char-list break-char-list :optional comment port)))
    (next-token-of (lambda (char-list/pred :optional port)))
    (read-string (lambda (n :optional port)))
    (make-text-progress-bar (lambda (:key (header) (header-width) (bar-char) (bar-width) (num-width) (num-format) (time-width) (info) (info-width) (separator-char) (max-value) (port))))
    (sql-tokenize (lambda (sql-string)))
    (tr (lambda (from-list to-list :key (:complement) (:delete) (:squeeze) (:table-size) (:input) (:output))))
    (string-tr (lambda (string from-list to-list :key (:complement) (:delete) (:squeeze) (:table-size))))
    (build-transliterator (lambda (from-list to-list :key (:complement) (:delete) (:squeeze) (:table-size) (:input) (:output))))
    (tree->string (lambda (tree)))
    (ucs4->utf8 (lambda (codepoint :optional strictness)))
    (utf8-length (lambda (octet :optional strictness)))
    (utf8->ucs4 (lambda (octet-list :optional strictness)))
    (ucs4->utf16 (lambda (codepoint :optional strictness)))
    (utf16-length (lambda (octet :optional strictness)))
    (utf16->ucs4 (lambda (octet-list :optional strictness)))
    (string->words (lambda (string)))
    (codepoints->words (lambda (sequence)))
    (string->grapheme-clusters (lambda (string)))
    (codepoints->grapheme-clusters (lambda (sequence)))
    (make-word-breaker (lambda (generator)))
    (make-grapheme-cluster-breaker (lambda (generator)))
    (make-word-reader (lambda (generator return)))
    (make-grapheme-cluster-reader (lambda (generator return)))
    (string-upcase (lambda (string)))
    (string-downcase (lambda (string)))
    (string-titlecase (lambda (string)))
    (string-foldcase (lambda (string)))
    (codepoints-upcase (lambda (sequence)))
    (codepoints-downcase (lambda (sequence)))
    (codepoints-titlecase (lambda (sequence)))
    (codepoints-foldcase (lambda (sequence)))
    (permutations (lambda (set)))
    (permutations* (lambda (set :optional eq)))
    (permutations-for-each (lambda (proc set)))
    (permutations*-for-each (lambda (proc set :optional eq)))
    (combinations (lambda (set n)))
    (combinations* (lambda (set n :optional eq)))
    (combinations-for-each (lambda (proc set n)))
    (combinations*-for-each (lambda (proc set n :optional eq)))
    (power-set (lambda (set)))
    (power-set* (lambda (set :optional eq)))
    (power-set-for-each (lambda (proc set)))
    (power-set*-for-each (lambda (proc set :optional eq)))
    (power-set-binary (lambda (set)))
    (cartesian-product (lambda (list-of-sets)))
    (cartesian-product-right (lambda (list-of-sets)))
    (digest-hexify (lambda (digest-result)))
    (isomorphic\? (lambda (obj1 obj2 :optional context)))
    (lcs (lambda (seq-a seq-b :optional eq-fn)))
    (lcs-with-positions (lambda (seq-a seq-b :optional eq-fn)))
    (lcs-fold (lambda (a-proc b-proc both-proc seed a b :optional eq-fn)))
    (lcs-edit-list (lambda (a b :optional eq-fn)))
    (match (syntax (expr clause \.\.\.)))
    (match-lambda (syntax (clause \.\.\.)))
    (match-lambda* (syntax (clause \.\.\.)))
    (match-let (syntax (\(\(pat\ expr\)\ \.\.\.\) body-expr \.\.\.)))
    (match-let (syntax (name \(\(pat\ expr\)\ \.\.\.\) body-expr \.\.\.)))
    (match-let* (syntax (\(\(pat\ expr\)\ \.\.\.\) body-expr \.\.\.)))
    (match-letrec (syntax (\(\(pat\ expr\)\ \.\.\.\) body-expr \.\.\.)))
    (match-let1 (syntax (pat expr body-expr \.\.\.)))
    (match-define (syntax (pat expr)))
    (make-queue (lambda nil))
    (make-mtqueue (lambda (&key max-length)))
    (queue\? (lambda (obj)))
    (mtqueue\? (lambda (obj)))
    (queue-empty\? (lambda (queue)))
    (queue-length (lambda (queue)))
    (mtqueue-max-length (lambda (mtqueue)))
    (mtqueue-room (lambda (mtqueue)))
    (copy-queue (lambda (queue)))
    (enqueue! (lambda (queue obj :optional more-objs \.\.\.)))
    (queue-push! (lambda (queue obj :optional more-objs \.\.\.)))
    (enqueue-unique! (lambda (queue eq-proc obj :optional more-objs \.\.\.)))
    (queue-push-unique! (lambda (queue eq-proc obj :optional more-objs \.\.\.)))
    (dequeue! (lambda (queue :optional fallback)))
    (queue-pop! (lambda (queue :optional fallback)))
    (dequeue-all! (lambda (queue)))
    (queue-front (lambda (queue :optional fallback)))
    (queue-rear (lambda (queue :optional fallback)))
    (list->queue (lambda (list :optional class :rest initargs)))
    (queue->list (lambda (queue)))
    (find-in-queue (lambda (pred queue)))
    (any-in-queue (lambda (pred queue)))
    (every-in-queue (lambda (pred queue)))
    (remove-from-queue! (lambda (pred queue)))
    (enqueue/wait! (lambda (mtqueue obj :optional timeout timeout-val)))
    (queue-push/wait! (lambda (mtqueue obj :optional timeout timeout-val)))
    (dequeue/wait! (lambda (mtqueue :optional timeout timeout-val)))
    (queue-pop/wait! (lambda (mtqueue :optional timeout timeout-val)))
    (make-rbtree (lambda (key=\? key<\?)))
    (rbtree-copy (lambda (rbtree)))
    (rbtree-empty\? (lambda (rbtree)))
    (rbtree-num-entries (lambda (rbtree)))
    (rbtree-exists\? (lambda (rbtree key)))
    (rbtree-get (lambda (rbtree key :optional fallback)))
    (rbtree-put! (lambda (rbtree key value)))
    (rbtree-delete! (lambda (rbtree key)))
    (rbtree-update! (lambda (rbtree key proc :optional fallback)))
    (rbtree-push! (lambda (rbtree key value)))
    (rbtree-pop! (lambda (rbtree key :optional fallback)))
    (rbtree-min (lambda (rbtree :optional fallback)))
    (rbtree-max (lambda (rbtree :optional fallback)))
    (rbtree-extract-min! (lambda (rbtree :optional fallback)))
    (rbtree-extract-max! (lambda (rbtree :optional fallback)))
    (rbtree-fold (lambda (rbtree proc seed)))
    (rbtree-fold-right (lambda (rbtree proc seed)))
    (rbtree-keys (lambda (rbtree)))
    (rbtree-values (lambda (rbtree)))
    (rbtree->alist (lambda (rbtree)))
    (alist->rbtree (lambda (alist key=\? key<\?)))
    (make-record-type (lambda (type-name field-names)))
    (record-constructor (lambda (rtd :optional field-names)))
    (record-predicate (lambda (rtd)))
    (record-accessor (lambda (rtd field-name)))
    (record-modifier (lambda (rtd field-name)))
    (make-sparse-vector (lambda (:optional type)))
    (sparse-vector-max-index-bits (lambda nil))
    (sparse-vector-copy (lambda (sv)))
    (sparse-vector-ref (lambda (sv k :optional default)))
    (sparse-vector-set! (lambda (sv k value)))
    (sparse-vector-num-entries (lambda (sv)))
    (sparse-vector-exists\? (lambda (sv k)))
    (sparse-vector-delete! (lambda (sv k)))
    (sparse-vector-clear! (lambda (sv)))
    (sparse-vector-inc! (lambda (sv k delta :optional \(fallback\ 0\))))
    (sparse-vector-update! (lambda (sv k proc :optional fallback)))
    (sparse-vector-push! (lambda (sv k val)))
    (sparse-vector-pop! (lambda (sv k :optional fallback)))
    (sparse-vector-fold (lambda (sv proc seed)))
    (sparse-vector-for-each (lambda (sv proc)))
    (sparse-vector-map (lambda (sv proc)))
    (sparse-vector-keys (lambda (sv)))
    (sparse-vector-values (lambda (sv)))
    (make-sparse-table (lambda (type)))
    (sparse-table-copy (lambda (st)))
    (sparse-table-num-entries (lambda (st)))
    (sparse-table-ref (lambda (st key :optional fallback)))
    (sparse-table-set! (lambda (st key value)))
    (sparse-table-exists\? (lambda (st key)))
    (sparse-table-delete! (lambda (st key)))
    (sparse-table-clear! (lambda (st)))
    (sparse-table-update! (lambda (st key proc :optional fallback)))
    (sparse-table-push! (lambda (st key val)))
    (sparse-table-pop! (lambda (st key :optional fallback)))
    (sparse-table-fold (lambda (st proc seed)))
    (sparse-table-for-each (lambda (st proc)))
    (sparse-table-map (lambda (st proc)))
    (sparse-table-keys (lambda (st)))
    (sparse-table-values (lambda (st)))
    (stream\? (lambda (obj)))
    (stream-cons (syntax (object stream)))
    (stream-null\? (lambda (obj)))
    (stream-pair\? (lambda (obj)))
    (stream-car (lambda (s)))
    (stream-cdr (lambda (s)))
    (stream-delay (syntax (expr)))
    (stream (lambda (obj \.\.\.)))
    (stream-unfoldn (lambda (generator seed n)))
    (stream-map (lambda (func)))
    (stream-for-each (lambda (func)))
    (stream-filter (lambda (pred\? stream)))
    (stream-xcons (lambda (a b)))
    (stream-cons* (lambda (elt \.\.\. stream)))
    (make-stream (lambda (n :optional init)))
    (stream-tabulate (lambda (n init-proc)))
    (stream-format (lambda (fmt arg \.\.\.)))
    (stream->list (lambda (stream)))
    (stream->string (lambda (stream)))
    (list->stream (lambda (list)))
    (string->stream (lambda (string :optional stream)))
    (port->stream (lambda (:optional iport reader closer)))
    (iterator->stream (lambda (iter)))
    (stream-lines (lambda (stream)))
    (stream= (lambda (elt= stream \.\.\.)))
    (stream-prefix= (lambda (stream prefix :optional elt=)))
    (stream-caar (lambda (s)))
    (stream-cadr (lambda (s)))
    (stream-cdddar (lambda (s)))
    (stream-cddddr (lambda (s)))
    (stream-ref (lambda (stream pos)))
    (stream-first (lambda (s)))
    (stream-second (lambda (s)))
    (stream-third (lambda (s)))
    (stream-fourth (lambda (s)))
    (stream-fifth (lambda (s)))
    (stream-sixth (lambda (s)))
    (stream-seventh (lambda (s)))
    (stream-eighth (lambda (s)))
    (stream-ninth (lambda (s)))
    (stream-tenth (lambda (s)))
    (stream-take (lambda (stream count)))
    (stream-take-safe (lambda (stream count)))
    (stream-drop (lambda (stream count)))
    (stream-drop-safe (lambda (stream count)))
    (stream-intersperse (lambda (stream element)))
    (stream-split (lambda (stream pred)))
    (stream-last (lambda (stream)))
    (stream-last-n (lambda (stream count)))
    (stream-butlast (lambda (stream)))
    (stream-butlast-n (lambda (stream count)))
    (stream-length (lambda (stream)))
    (stream-length>= (lambda (stream n)))
    (stream-append (lambda (stream \.\.\.)))
    (stream-concatenate (lambda (streams)))
    (stream-reverse (lambda (stream :optional tail-stream)))
    (stream-count (lambda (pred stream \.\.\.)))
    (stream-remove (lambda (pred stream)))
    (stream-partition (lambda (pred stream)))
    (stream-find (lambda (pred stream)))
    (stream-find-tail (lambda (pred stream)))
    (stream-take-while (lambda (pred stream)))
    (stream-drop-while (lambda (pred stream)))
    (stream-span (lambda (pred stream)))
    (stream-break (lambda (pred stream)))
    (stream-any (lambda (pred stream \.\.\.)))
    (stream-every (lambda (pred stream \.\.\.)))
    (stream-index (lambda (pred stream \.\.\.)))
    (stream-member (lambda (obj stream :optional elt=)))
    (stream-memq (lambda (obj stream)))
    (stream-memv (lambda (obj stream)))
    (stream-delete (lambda (obj stream :optional elt=)))
    (stream-delete-duplicates (lambda (stream :optional elt=)))
    (stream-grep (lambda (re stream)))
    (write-stream (lambda (stream :optional oport writer)))
    (make-trie (lambda (:optional tab-make tab-get tab-put! tab-fold)))
    (trie (lambda (params kv \.\.\.)))
    (trie-with-keys (lambda (params key \.\.\.)))
    (trie\? (lambda (obj)))
    (trie-num-entries (lambda (trie)))
    (trie-exists\? (lambda (trie key)))
    (trie-get (lambda (trie key :optional fallback)))
    (trie-put! (lambda (trie key value)))
    (trie-update! (lambda (trie key proc :optional fallback)))
    (trie-delete! (lambda (trie key)))
    (trie->list (lambda (trie)))
    (trie-keys (lambda (trie)))
    (trie-values (lambda (trie)))
    (trie->hash-table (lambda (trie ht-type)))
    (trie-common-prefix (lambda (trie prefix)))
    (trie-common-prefix-keys (lambda (trie prefix)))
    (trie-common-prefix-values (lambda (trie prefix)))
    (trie-common-prefix-fold (lambda (trie prefix proc seed)))
    (trie-common-prefix-map (lambda (trie prefix proc)))
    (trie-common-prefix-for-each (lambda (trie prefix proc)))
    (trie-fold (lambda (trie proc seed)))
    (trie-map (lambda (trie proc)))
    (trie-for-each (lambda (trie proc)))
    (topological-sort (lambda (graph :optional eqproc)))
    (cgi-get-metavariable (lambda (name)))
    (cgi-parse-parameters (lambda (:key (:query-string) (:merge-cookies) (:part-handlers))))
    (cgi-get-parameter (lambda (name params :key (:default) (:list) (:convert))))
    (cgi-header (lambda (:key (status) (content-type) (location) (cookies))))
    (cgi-main (lambda (proc :key (on-error) (merge-cookies) (output-proc) (part-handlers))))
    (cgi-add-temporary-file (lambda (filename)))
    (cgi-test-enviornment-ref (lambda (envvar-name)))
    (call-with-cgi-script (lambda (script proc :key (\(environment\ nil\)))))
    (run-cgi-script->header&body (lambda (script reader :key (environment) (parameters))))
    (run-cgi-script->sxml (lambda (script :key (environment) (parameters))))
    (run-cgi-script->string (lambda (script :key (environment) (parameters))))
    (run-cgi-script->string-list (lambda (script :key (environment) (parameters))))
    (object-equal\? (lambda (obj1 obj2)))
    (x->number (lambda (obj)))
    (x->integer (lambda (obj)))
    (default-endian (lambda nil))
    (x->string (lambda (obj)))
    (object-hash (lambda (obj)))
    (ref (lambda (\(ht\ <hash-table>\) key :optional default)))
    (ref (lambda (object key :optional args \.\.\.)))
    (object-apply (lambda (object arg \.\.\.)))
    (write-object (lambda (\(obj\ <object>\) port)))
    (object-compare (lambda (obj1 obj2)))
    (debug-print-width (lambda nil))
    (make (lambda nil))
    (make (lambda (\(class\ <class>\) arg \.\.\.)))
    (allocate-instance (lambda nil))
    (allocate-instance (lambda (\(class\ <class>\) initargs)))
    (initialize (lambda nil))
    (initialize (lambda (\(obj\ <object>\) initargs)))
    (ref (lambda (\(obj\ <object>\) \(slot\ <symbol>\))))
    (slot-unbound (lambda nil))
    (slot-unbound (lambda (\(class\ <class>\) obj slot)))
    (slot-missing (lambda nil))
    (slot-missing (lambda (\(class\ <class>\) obj slot :optional value)))
    (slot-ref-using-class (lambda (\(class\ <class>\) \(obj\ <object>\) slot-name)))
    (slot-set-using-class! (lambda (\(class\ <class>\) \(obj\ <object>\) slot-name value)))
    (slot-bound-using-class\? (lambda (\(class\ <class>\) \(obj\ <object>\) slot-name)))
    (change-class (lambda nil))
    (change-class (lambda (\(obj\ <object>\) \(new-class\ <class>\))))
    (next-method (lambda nil))
    (next-method (lambda (args \.\.\.)))
    (make (lambda (\(class\ <class>\) :rest initargs)))
    (compute-slots (lambda nil))
    (compute-get-n-set (lambda nil))
    (compute-slot-accessor (lambda nil))
    (compute-slot-accessor (lambda (\(class\ <class>\) slot access-specifier)))
    (compute-slots (lambda (\(class\ <class>\))))
    (compute-get-n-set (lambda (\(class\ <class>\) slot)))
    (make (lambda (\(class\ <method>\) :rest initargs)))
    (apply-generic (lambda (gf args)))
    (sort-applicable-methods (lambda (gf methods args)))
    (method-more-specific\? (lambda (method1 method2 classes)))
    (apply-methods (lambda (gf methods args)))
    (apply-method (lambda (gf method build-next args)))
    (cgen-current-unit (lambda nil))
    (cgen-emit-c (lambda (cgen-unit)))
    (cgen-emit-h (lambda (cgen-unit)))
    (cgen-unit-c-file (lambda (cgen-unit)))
    (cgen-unit-h-file (lambda (cgen-unit)))
    (cgen-unit-init-name (lambda (cgen-unit)))
    (cgen-emit-xtrn (lambda (cgen-node)))
    (cgen-emit-decl (lambda (cgen-node)))
    (cgen-emit-body (lambda (cgen-node)))
    (cgen-emit-init (lambda (cgen-node)))
    (cgen-cexpr (lambda (cgen-literal)))
    (fold (lambda (proc knil coll coll2 \.\.\.)))
    (fold2 (lambda (proc knil1 knil2 coll coll2 \.\.\.)))
    (fold3 (lambda (proc knil1 knil2 knil3 coll coll2 \.\.\.)))
    (map (lambda (proc coll coll2 \.\.\.)))
    (map-to (lambda (class proc coll coll2 \.\.\.)))
    (map-accum (lambda (proc seed coll1 coll2 \.\.\.)))
    (for-each (lambda (proc coll coll2 \.\.\.)))
    (fold$ (lambda (proc)))
    (fold$ (lambda (proc knil)))
    (map$ (lambda (proc)))
    (for-each$ (lambda (proc)))
    (find (lambda (pred coll)))
    (find-min (lambda (coll :key (key) (compare) (default))))
    (find-max (lambda (coll :key (key) (compare) (default))))
    (find-min&max (lambda (coll :key (key) (compare) (default) (default-min) (default-max))))
    (filter (lambda (pred coll)))
    (filter-to (lambda (class pred coll)))
    (remove (lambda (pred coll)))
    (remove-to (lambda (class pred coll)))
    (partition (lambda (pred coll)))
    (partition-to (lambda (class pred coll)))
    (group-collection (lambda (coll :key (key) (test))))
    (size-of (lambda (coll)))
    (lazy-size-of (lambda (coll)))
    (coerce-to (lambda (class coll)))
    (call-with-iterator (lambda (collection proc :key (start))))
    (with-iterator (lambda (\(collection\ end\?\ next\ args\ \.\.\.\) body \.\.\.)))
    (call-with-builder (lambda (collection-class proc :key (size))))
    (with-builder (lambda (\(collection\ add!\ get\ args\ \.\.\.\) body \.\.\.)))
    (dict-get (lambda (\(dict\ <dictionary>\) key :optional default)))
    (dict-put! (lambda (\(dict\ <dictionary>\) key value)))
    (dict-exists\? (lambda (\(dict\ <dictionary>\) key)))
    (dict-delete! (lambda (\(dict\ <dictionary>\) key)))
    (dict-fold (lambda (\(dict\ <dictionary>\) proc seed)))
    (dict-fold-right (lambda (\(dict\ <ordered-dictionary>\) proc seed)))
    (dict-for-each (lambda (\(dict\ <dictionary>\) proc)))
    (dict-map (lambda (\(dict\ <dictionary>\) proc)))
    (dict-keys (lambda (\(dict\ <dictionary>\))))
    (dict-values (lambda (\(dict\ <dictionary>\))))
    (x->generator (lambda (obj)))
    (add-hook! (lambda (\(hook\ <hook>\) proc :optional)))
    (delete-hook! (lambda (\(hook\ <hook>\) proc)))
    (remove-hook! (lambda (\(hook\ <hook>\) proc)))
    (reset-hook! (lambda (\(hook\ <hook>\))))
    (hook->list (lambda (\(hook\ <hook>\))))
    (run-hook (lambda (\(hook\ <hook>\) arg \.\.\.)))
    (describe (lambda (obj)))
    (d (lambda (obj)))
    (listener-read-handler (lambda (\(listener\ <listener>\))))
    (listener-show-prompt (lambda (\(listener\ <listener>\))))
    (log-default-drain (lambda nil))
    (log-format (lambda (\(format\ <string>\) arg \.\.\.)))
    (log-format (lambda (\(drain\ <log-drain>\) \(format\ <string>\) arg \.\.\.)))
    (instance-of (lambda (\(class\ <singleton-meta>\) :rest initargs)))
    (sockaddr-family (lambda (addr)))
    (sockaddr-name (lambda (addr)))
    (sockaddr-family (lambda (\(addr\ <sockaddr-in>\))))
    (sockaddr-name (lambda (\(addr\ <sockaddr-in>\))))
    (sockaddr-addr (lambda (\(addr\ <sockaddr-in>\))))
    (sockaddr-port (lambda (\(addr\ <sockaddr-in>\))))
    (sockaddr-family (lambda (\(addr\ <sockaddr-un>\))))
    (sockaddr-name (lambda (\(addr\ <sockaddr-un>\))))
    (parameter-observer-add! (lambda (\(p\ <parameter>\) proc :optional when where)))
    (parameter-observer-delete! (lambda (\(p\ <parameter>\) proc :optional when)))
    (parameter-pre-observers (lambda (\(p\ <parameter>\))))
    (parameter-post-observers (lambda (\(p\ <parameter>\))))
    (process-pid (lambda (\(process\ <process>\))))
    (process-command (lambda (\(process\ <process>\))))
    (process-input (lambda (\(process\ <process>\) :optional name)))
    (process-output (lambda (\(process\ <process>\) :optional name)))
    (process-error (lambda (\(process\ <process>\))))
    (selector-add! (lambda (\(self\ <selector>\) port-or-fd proc flags)))
    (selector-delete! (lambda (\(self\ <selector>\) port-or-fd proc flags)))
    (selector-select (lambda (\(self\ <selector>\) :optional)))
    (ref (lambda (\(seq\ <sequence>\) index :optional fallback)))
    (referencer (lambda (\(seq\ <sequence>\))))
    (modifier (lambda (\(seq\ <sequence>\))))
    (subseq (lambda (\(seq\ <sequence>\) :optional start end)))
    (fold-with-index (lambda (kons knil \(seq\ <sequence>\) \.\.\.)))
    (map-with-index (lambda (proc \(seq\ <sequence>\) \.\.\.)))
    (map-to-with-index (lambda (class proc \(seq\ <sequence>\) \.\.\.)))
    (for-each-with-index (lambda (proc \(seq\ <sequence>\) \.\.\.)))
    (find-with-index (lambda (pred \(seq\ <sequence>\))))
    (find-index (lambda (pred \(seq\ <sequence>\))))
    (fold-right (lambda (kons knil \(seq\ <sequence>\) \.\.\.)))
    (group-sequence (lambda (seq :key (key) (test))))
    (permute (lambda (\(src\ <sequence>\) \(permuter\ <sequence>\) :optional fallback)))
    (permute-to (lambda (\(class\ <class>\) \(src\ <sequence>\) \(permuter\ <sequence>\) :optional fallback)))
    (permute! (lambda (\(src\ <sequence>\) \(permuter\ <sequence>\) :optional fallback)))
    (shuffle (lambda (\(src\ <sequence>\) :optional random-source)))
    (shuffle-to (lambda (\(class\ <class>\) \(src\ <sequence>\) :optional random-source)))
    (shuffle! (lambda (\(src\ <sequence>\) :optional random-source)))
    (time-counter-start! (lambda (\(counter\ <time-counter>\))))
    (time-counter-stop! (lambda (\(counter\ <time-counter>\))))
    (time-counter-reset! (lambda (\(counter\ <time-counter>\))))
    (time-counter-value (lambda (\(counter\ <time-counter>\))))
    (program (lambda (program-clause program-clause2 \.\.\.)))
    (requires (lambda (feature-id feature-id2 \.\.\.)))
    (files (lambda (filename \.\.\.)))
    (code (lambda (scheme-expression \.\.\.)))
    (feature-cond (lambda (clause clause2 \.\.\.)))
    (current-language (lambda nil))
    (current-country (lambda nil))
    (current-locale-details (lambda nil))
    (dbi-open\? (lambda (\(c\ <dbi-connection>\))))
    (dbi-close (lambda (\(c\ <dbi-connection>\))))
    (dbi-prepare (lambda (conn sql :key (pass-through) (\.\.\.))))
    (dbi-open\? (lambda (\(q\ <dbi-query>\))))
    (dbi-close (lambda (\(q\ <dbi-query>\))))
    (dbi-execute (lambda (\(q\ <dbi-query>\) parameter \.\.\.)))
    (dbi-do (lambda (conn sql :optional options parameter-value \.\.\.)))
    (dbi-escape-sql (lambda (conn str)))
    (dbi-open\? (lambda (result)))
    (dbi-close (lambda (result)))
    (dbi-make-connection (lambda (\(d\ <foo-driver>\) \(options\ <string>\) \(option-alist\ <list>\) :key (username) (password) (\.\.\.))))
    (dbi-prepare (lambda (\(c\ <foo-connection>\) \(sql\ <string>\) :key (pass-through) (\.\.\.))))
    (dbi-execute-using-connection (lambda (\(c\ <foo-connection>\) \(q\ <dbi-query>\) \(params\ <list>\))))
    (dbi-escape-sql (lambda (\(c\ <foo-connection>\) str)))
    (dbi-open\? (lambda (\(c\ <foo-connection>\))))
    (dbi-open\? (lambda (\(q\ <foo-query>\))))
    (dbi-open\? (lambda (\(r\ <foo-result>\))))
    (dbi-close (lambda (\(c\ <foo-connection>\))))
    (dbi-close (lambda (\(q\ <foo-query>\))))
    (dbi-close (lambda (\(r\ <foo-result>\))))
    (dbi-do (lambda (\(c\ <foo-connection>\) \(sql\ <string>\) :optional options parameter-value \.\.\.)))
    (dbm-open (lambda (\(dbm\ <dbm>\))))
    (dbm-open (lambda (\(dbm-class\ <dbm-meta>\) options \.\.\.)))
    (dbm-close (lambda (\(dbm\ <dbm>\))))
    (dbm-closed\? (lambda (\(dbm\ <dbm>\))))
    (dbm-put! (lambda (\(dbm\ <dbm>\) key value)))
    (dbm-get (lambda (\(dbm\ <dbm>\) key :optional default)))
    (dbm-exists\? (lambda (\(dbm\ <dbm>\) key)))
    (dbm-delete! (lambda (\(dbm\ <dbm>\) key)))
    (dbm-fold (lambda (\(dbm\ <dbm>\) procedure knil)))
    (dbm-for-each (lambda (\(dbm\ <dbm>\) procedure)))
    (dbm-map (lambda (\(dbm\ <dbm>\) procedure)))
    (dbm-db-exists\? (lambda (class name)))
    (dbm-db-remove (lambda (class name)))
    (dbm-db-copy (lambda (class from to)))
    (dbm-db-move (lambda (class from to)))
    (temporary-directory (lambda nil))
    (file-mtime=\? (lambda (f1 f2)))
    (file-mtime<\? (lambda (f1 f2)))
    (file-mtime<=\? (lambda (f1 f2)))
    (file-mtime>\? (lambda (f1 f2)))
    (file-mtime>=\? (lambda (f1 f2)))
    (file-ctime=\? (lambda (f1 f2)))
    (file-atime=\? (lambda (f1 f2)))
    (hmac-update! (lambda (\(hmac\ <hmac>\) data)))
    (hmac-final! (lambda (\(hmac\ <hmac>\))))
    (hmac-digest (lambda (:key (key) (hasher))))
    (hmac-digest-string (lambda (string :key (key) (hasher))))
    (http-user-agent (lambda (:optional value)))
    (http-proxy (lambda (:optional value)))
    (http-default-redirect-handler (lambda (:optional value)))
    (<sql-parse-error> (lambda nil))
    (write-tree (lambda (tree :optional out)))
    (write-tree (lambda (\(\(tree\ <list>\)\ out\))))
    (write-tree (lambda (\(\(tree\ <top>\)\ out\))))
    (digest-update! (lambda (algorithm data)))
    (digest-final! (lambda (algorithm)))
    (digest (lambda (class)))
    (digest-string (lambda (class string)))
    (object-isomorphic\? (lambda (obj1 obj2 context)))
    (relation-column-names (lambda (\(r\ <relation>\))))
    (relation-accessor (lambda (\(r\ <relation>\))))
    (relation-modifier (lambda (\(r\ <relation>\))))
    (relation-rows (lambda (\(r\ <relation>\))))
    (relation-column-name\? (lambda (\(r\ <relation>\) column)))
    (relation-column-getter (lambda (\(r\ <relation>\) column)))
    (relation-column-setter (lambda (\(r\ <relation>\) column)))
    (relation-ref (lambda (\(r\ <relation>\) row column :optional default)))
    (relation-set! (lambda (\(r\ <relation>\) row column value)))
    (relation-column-getters (lambda (\(r\ <relation>\))))
    (relation-column-setters (lambda (\(r\ <relation>\))))
    (relation-coercer (lambda (\(r\ <relation>\))))
    (relation-insertable\? (lambda (\(r\ <relation>\))))
    (relation-insert! (lambda (\(r\ <relation>\) row)))
    (relation-deletable\? (lambda (\(r\ <relation>\))))
    (relation-delete! (lambda (\(r\ <relation>\) row)))
    (relation-fold (lambda (\(r\ <relation>\) proc seed column \.\.\.)))
    (cgi-metavariables (lambda (:optional metavariables)))
    (cgi-output-character-encoding (lambda (:optional encoding)))
    (cgi-temporary-files (lambda nil))
    ))


;; (gosh-dev-parse-and-insert "~/src/System/gauche/Gauche-0.9.1/doc/gauche-refe.texi")

(provide 'gosh-dev)

;;; gosh-dev.el ends here
